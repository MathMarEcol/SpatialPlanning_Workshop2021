[["index.html", "2021 UQ Spatial Planning Workshop using Prioritizr Chapter 1 Welcome!", " 2021 UQ Spatial Planning Workshop using Prioritizr Jason D. Everett, Isaac Brito-Morales 2021-02-02 Chapter 1 Welcome! The aim of this workshop is to help you get started with using the prioritizr R package for systematic conservation planning. It is not designed to give you a comprehensive overview and you will not become an expert after completing this workshop. Instead, we want to help you understand the core principles of conservation planning and guide you through some of the common tasks involved with developing prioritizations. In other words, we want to give you the knowledge base and confidence needed to start applying systematic conservation planning to your own work. install.packages(&quot;bookdown&quot;) # or the development version # devtools::install_github(&quot;rstudio/bookdown&quot;) "],["setup.html", "Chapter 2 Setting up your computer 2.1 R 2.2 RStudio 2.3 R packages 2.4 Optimisation Software", " Chapter 2 Setting up your computer You will need to have both R and RStudio installed on your computer to complete this workshop. Although it is not imperative that you have the latest version of RStudio installed, you will need the latest version of R installed (i.e. version 4.0.3). Please note that you might need administrative permissions to install these programs. After installing them, you will also need to install some R packages too. Finally, you will also need to download the data for this workshop. 2.1 R The R statistical computing environment can be downloaded from the Comprehensive R Archive Network (CRAN). Specifically, you can download the latest version of R (version 4.0.3) from here: https://cloud.r-project.org. Please note that you will need to download the correct file for your operating system (i.e. Linux, Mac OSX, Windows). 2.2 RStudio RStudio is an integrated development environment (IDE). In other words, it is a program that is designed to make your R programming experience more enjoyable. During this workshop, you will interact with R through RStudio—meaning that you will open RStudio to code in R. You can download the latest version of RStudio here: http://www.rstudio.com/download. When you start RStudio, you will see two main parts of the interface: You can type R code into the Console and press the enter key to run code. 2.3 R packages An R package is a collection of R code and documentation that can be installed to enhance the standard R environment with additional functionality. Currently, there are over fifteen thousand R packages available on CRAN. Each of these R packages are developed to perform a specific task, such as reading Excel spreadsheets, downloading satellite imagery data, downloading and cleaning protected area data, or fitting environmental niche models. In fact, R has such a diverse ecosystem of R packages, that the question is almost always not “can I use R to …?” but “what R package can I use to …?”. During this workshop, we will use several R packages. To install these R packages, please enter the code below in the Console part of the RStudio interface and press enter. Note that you will require an Internet connection and the installation process may take some time to complete. install.packages(c(&quot;sf&quot;, &quot;dplyr&quot;, &quot;sp&quot;, &quot;rgeos&quot;, &quot;rgdal&quot;, &quot;raster&quot;, &quot;units&quot;, &quot;prioritizr&quot;, &quot;prioritizrdata&quot;, &quot;Rsymphony&quot;, &quot;mapview&quot;, &quot;assertthat&quot;, &quot;remotes&quot;, &quot;gridExtra&quot;, &quot;BiocManager&quot;)) BiocManager::install(&quot;lpsymphony&quot;) 2.4 Optimisation Software Gurobi is the most powerful and fastest solver that the prioritizr R package can use to solve conservation planning problems. This vignette will walk you through the process of setting up Gurobi on your computer so that you can use it to solve conservation planning problems. If you encounter any problems while following the instructions below, check out the official Gurobi documentation. 2.4.1 Obtaining a license Gurobi is a commercial computer program. This means that users will need to obtain a license for Gurobi before they can use it. Although academics can obtain a special license at no cost, individuals that are not affiliated with a recognized educational institution may need to purchase a license to use Gurobi. If you are an academic that is affiliated with an educational institution, you can take advantage of the special academic license to use Gurobi for no cost. Once you have signed up for a free account you can request a free academic license. Once you accept the Terms Of Service you can generate a license. Now, copy and save the grbgetkey XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX command for later use. 2.4.2 Downloading the Gurobi software suite After obtaining a license, you will need to download a copy of the Gurobi installer to your computer. To achieve this, visit the Gurobi downloads web page and download the correct version of the installer for your operating system. 2.4.3 Software installation The installation process for the Gurobi software suite depends on the type of operating system you have installed on your computer. Fortunately, Gurobi provide platform-specific “Quick Start Guides” for Windows, Mac OSX, and Linux systems that should help with this. Briefly, on Windows and Mac systems, you just need to double-click on the Gurobi installer, follow the prompts, and the installer will take care of rest. After installing the Gurobi software suite on your computer, you will need to activate your license. 2.4.4 License activation Now we will activate the Gurobi software using the license you downloaded earlier. Please note that the correct set of instructions depends on your system and license. In most cases, you should follow the instructions in the “Local license activation”. If, and only if, you are activating a special Academic license on a networked computer that is not connected to your university’s network (e.g. a cloud-based system), then please follow the instructions below in the “Cloud license activation over SSH” section. 2.4.5 Local license activation To activate the license, simply copy and paste the grbgetkey command into your computer’s command prompt or terminal (note that Windows users can open the command prompt by typing cmd in the search box and pressing the enter key). After running the grbgetkey command with the correct license code, you should see output that looks something like that in the screen shot below. "],["overview-of-the-conservation-planning-problem.html", "Chapter 3 Overview of the conservation planning problem 3.1 Prioritizr / Marxan 3.2 Summary 3.3 Introduction 3.4 Package overview 3.5 Package work flow 3.6 Usage 3.7 Conclusion 3.8 References", " Chapter 3 Overview of the conservation planning problem Systematic conservation planning is widely considered “good practice” because it facilitates a transparent, inclusive and defensible planning process. In addition it embodies fundamental planning principles: Comprehensiveness : a reserve system that contains every feature of biodiversity interest that occurs within a particular region Efficiency : reserve network that meets the conservation objectives for the least possible cost Spatial arrangement : in reserve network design “the whole is more than the sum of the parts” (compactness of reserve system) Flexibility : a range of solutions that are reasonably good from an ecological perspective but also good for other considerations (e.g., economics, political, social) Complementarily : planning units complement each other well if the species or habitats they contain are different Selection frequency : *(From Marxan Good Practices Handbook 2013) Systematic conservation planning is a formal method for identifying potential areas for conservation management that will most efficiently achieve a specific set of objectives, commonly some minimum representation of biodiversity (Marxan Good Practices Handbook 2013). 3.1 Prioritizr / Marxan Prioritizr / Marxan : software that delivers decision support for reserve system design Marxan / : a software that uses stochastic optimisation routines (simulated annealing) to aid systematic reserve design on conservation planning rPrioritizr / : an R package that uses integer linear programming (ILP) techniques to provide a flexible interface for building and solving conservation planning problems 3.1.1 Algorithm vs Problem An algorithm is a method for finding good answers to a problem(s). Prioritizr and Marxan use different algorithms (integer linear programming and simulated annealing) to solve a problem(s). A scientific problem is a question that can be answered using the scientific method. DO NOT CONFUSE THEM 3.1.2 Key concepts There are several concepts that underpin the conservation planning problems. Some of them are: Planning units : Planning units are the building blocks of a reserve system. A study area is divided into planning units that are smaller geographic parcels of regular or irregular shapes Features : A conservation feature is a measurable, spatially definable component of biodiversity that is to be conserved within a reserve network (e.g., species, communities, habitat types, populations, etc.). In conservation planning analyses, each conservation feature is given a target, which is the amount of the conservation feature to be included within the reserve network Target / Representation target : Targets are the quantitative values (amounts) of each conservation feature to be achieved in the final reserve solution Cost : The cost of including a planning unit in a reserve system. This cost should reflect the socio-political constraints to setting aside that planning unit for conservation actions. This could be: total area, cost of acquisition or any other relative social, economic or ecological measure. Each planning unit is assigned one cost (although several measures can be combined to create a cost metric) Boundary Length Modifier (BLM) : A variable controlling how much emphasis to place on minimising the overall reserve system boundary length relative to the reserve system cost. Higher BLM values will produce a more compact reserve system 3.1.2.1 Marxan problem equation (#fig:Marxan problem equation)Marxan problem equation 3.1.2.2 Prioritizr minimum set objective The minimum set objective for the reserve design problem can be expressed mathematically for a set of planning units (I indexed by i ) and a set of features (J indexed by j) as (#fig:Prioritizr minimum objective)Prioritizr minimum set objective xi : the decision variable (e.g. specifying whether planning unit i has been selected (1) or not (0)) ci : the cost of planning unit i rij : the amount of feature j in planning unit i Tj : the target for feature j This says find the set of planning units that meets all the representation targets while minimizing the overall cost 3.1.3 Minimum Reserve Set Problem The Prioritizr minimum set objective seeks to find the set of planning units that minimizes the overall cost of a reserve network, while meeting a set of representation targets for the conservation features. This objective is equivalent to a simplified Marxan reserve design problem with the Boundary Length Modifier (BLM) set to zero. See the next video 3.2 Summary The prioritizr R package uses integer linear programming (ILP) techniques to provide a flexible interface for building and solving conservation planning problems (Rodrigues et al. 2000; Billionnet 2013). It supports a broad range of objectives, constraints, and penalties that can be used to custom-tailor conservation planning problems to the specific needs of a conservation planning exercise. Once built, conservation planning problems can be solved using a variety of commercial and open-source exact algorithm solvers. In contrast to the algorithms conventionally used to solve conservation problems, such as heuristics or simulated annealing (Ball et al. 2009), the exact algorithms used here are guaranteed to find optimal solutions. Furthermore, conservation problems can be constructed to optimize the spatial allocation of different management zone (or actions), meaning that conservation practitioners can identify solutions that benefit multiple stakeholders. Finally, this package has the functionality to read input data formatted for the Marxan conservation planning program (Ball et al. 2009), and find much cheaper solutions in a much shorter period of time than Marxan (Beyer et al. 2016). 3.3 Introduction Systematic conservation planning is a rigorous, repeatable, and structured approach to designing new protected areas that efficiently meet conservation objectives (Margules &amp; Pressey 2000). Historically, conservation decision-making has often evaluated parcels opportunistically as they became available for purchase, donation, or under threat. Although purchasing such areas may improve the status quo, such decisions may not substantially enhance the long-term persistence of target species or communities. Faced with this realization, conservation planners began using decision support tools to help simulate alternative reserve designs over a range of different biodiversity and management goals and, ultimately, guide protected area acquisitions and management actions. Due to the systematic, evidence-based nature of these tools, conservation prioritization can help contribute to a transparent, inclusive, and more defensible decision making process. A conservation planning exercise typically starts by defining a study area. This study area should encompass all the areas relevant to the decision maker or the hypothesis being tested. The extent of a study area could encompass a few important localities (e.g. Stigner et al. 2016), a single state (e.g. Kirkpatrick 1983), an entire country (Fuller et al. 2010), or the entire planet (Butchart et al. 2015). Next, the study area is divided into a set of discrete areas termed planning units. Each planning unit represents a discrete locality in the study area that can be managed independently of other areas. The general idea is that some combination of the planning units can be selected for conservation actions (e.g. protected area establishment, habitat restoration). Planning units are often created as square or hexagon cells that are sized according to the scale of the conservation actions, and the resolution of the data that underpin the planning exercise (but see Klein et al. 2009). Cost data (or a surrogate thereof) are needed to inform the prioritization process. Specifically, these cost data describe the relative expenditure associated with managing each planning unit for conservation. For example, if the goal of the conservation planning exercise is to identify priority areas for expanding a local protected area system, then the cost data could represent the physical cost of purchasing the land. Alternatively, if such data are not available, then surrogate data could are often used instead (e.g. human population density, opportunity cost of foregone commercial activities, or planning unit size). Conservation planning exercises also require data on the biodiversity elements that are of conservation interest (termed conservation features). These features could be species (e.g. Neofelis nebulosa, the Clouded Leopard), populations, or habitats (e.g. mangroves or cloud forest). After identifying the set of relevant conservation features for a conservation planning exercise, spatially explicit data need to be obtained for each and every feature to describe their spatial distribution (e.g. habitat suitability data, probability of occurrence data, presence/absence data). This is important to ensure that conservation features are adequately covered (represented) by prioritizations. After assembling all the data, the next step is to define the conservation planning problem. The prioritizr R package is designed to help you build and solve conservation planning problems. Specifically, prioritizations are generated by using formulating a mathematical optimization problem and then solving it to generate a solution. These mathematical optimization problems are formulated using the planning unit data, cost data, and feature data, and with information related to the overarching aim of the prioritization process. In general, the goal of an optimization problem is to minimize (or maximize) an objective function that is calculated using a set of decision variables, subject to a series of constraints to ensure that solution exhibits specific properties. The objective function describes the quantity which we are trying to minimize (e.g. cost of the solution) or maximize (e.g. number of features conserved). The decision variables describe the entities that we can control, and indicate which planning units are selected for conservation management and which of those are not. The constraints can be thought of as rules that the need decision variables need to follow. For example, a commonly used constraint is specifying that the solution must not exceed a certain budget. A wide variety of approaches have been developed for solving optimization problems. Reserve design problems are frequently solved using simulated annealing (Kirkpatrick et al. 1983) or heuristics (Nicholls &amp; Margules 1993; Moilanen 2007). These methods are conceptually simple and can be applied to a wide variety of optimization problems. However, they do not scale well for large or complex problems (Beyer et al. 2016). Additionally, these methods cannot tell you how close any given solution is to the optimal solution. The prioritizr R package uses exact algorithms to efficiently solve conservation planning problems to within a pre-specified a optimality gap. In other words, you can specify that you need the optimal solution (i.e. a gap of 0%) and the algorithms will, given enough time, find a solution that meets this criteria. In the past, exact algorithms have been too slow for conservation planning exercises (Pressey et al. 1996). However, improvements over the last decade mean that they are now much faster (Achterberg &amp; Wunderling 2013; Beyer et al. 2016). In this package, optimization problems are expressed using integer linear programming (ILP) so that they can be solved using (linear) exact algorithm solvers. The general form of an integer programming problem can be expressed in matrix notation using the following equation. \\[\\text{Minimize} \\space \\boldsymbol{c}^\\text{T} \\boldsymbol{x} \\space \\space \\text{subject to} \\space A\\boldsymbol{x} \\space \\Box \\space \\boldsymbol{b}\\] Here, where \\(x\\) is a vector of decision variables, \\(c\\) and \\(b\\) are vectors of known coefficients, and \\(A\\) is the constraint matrix. The final term specifies a series of structural constants and the \\(\\Box\\) symbol is used to indicate that the relational operators for the constraints can be either \\(\\geq\\), \\(=\\), or \\(\\leq\\). In the context of a conservation planning problem, \\(c\\) could be used to represent the planning unit costs, \\(A\\) could be used to store the data showing the presence / absence (or amount) of each feature in each planning unit, \\(b\\) could be used to represent minimum amount of habitat required for each species in the solution, the \\(\\Box\\) could be set to \\(\\geq\\) symbols to indicate that the total amount of each feature in the solution must exceed the quantities in \\(b\\). But there are many other ways of formulating the reserve selection problem (Rodrigues et al. 2000). 3.4 Package overview The prioritizr R package contains eight main types of functions. These functions are used to: create a new conservation planning problem by specifying the planning units, features, and management zones of conservation interest (e.g. species, ecosystems). add an objective to a conservation planning problem. add targets to a problem to specify how much of each feature is desired or required to be conserved in the solutions. add constraints to a conservation planning problem to ensure that solutions exhibit specific properties (e.g. select specific planning units for protection). add penalties to a problem to penalize solutions according to specific metric (e.g. connectivity). add decisions to a problem to specify the nature of the decisions in the problem. add methods to generate a portfolio of solutions. add a solver to a conservation problem to specify which software should be used to generate solutions and customize the optimization process. solve a conservation problem. evaluate a solution by computing summary statistics. evaluate the relative importance (irreplaceability) of planning units selected in a solution. 3.5 Package work flow The general work flow when using the prioritizr R package starts with creating a new conservation planning problem object using data. Specifically, the problem object should be constructed using data that specify the planning units, biodiversity features, management zones (if applicable), and costs. After creating a new problem object, it can be customized—by adding objectives, penalties, constraints, and other information—to build a precise representation of the conservation planning problem required, and then solved to obtain a solutions. All conservation planning problems require an objective. An objective specifies the property which is used to compare different feasible solutions. Simply put, the objective is the property of the solution which should be maximized or minimized during the optimization process. For instance, with the minimum set objective (specified using add_min_set_objective), we are seeking to minimize the cost of the solution (similar to Marxan). On the other hand, with the maximum coverage objective (specified using add_max_cover_objective), we are seeking to maximize the number of different features represented in the solution. Many objectives require targets (e.g. the minimum set objective). Targets are a specialized set of constraints that relate to the total quantity of each feature secured in the solution (e.g. amount of suitable habitat or number of individuals). In the case of the minimum set objective ( add_min_set_objective), they are used to ensure that solutions secure a sufficient quantity of each feature, and in other objectives, such as the maximum features objective ( add_max_features_objective) they are used to assess whether a feature has been adequately conserved by a candidate solution. Targets can be expressed numerically as the total amount required for a given feature (using add_absolute_targets), or as a proportion of the total amount found in the planning units (using add_relative_targets). Note that not all objectives require targets, and a warning will be thrown if an attempt is made to add targets to a problem with an objective that does not use them. Constraints and penalties can be added to a conservation planning problem to ensure that solutions exhibit a specific property or penalize solutions which don’t exhibit a specific property (respectively). The difference between constraints and penalties, strictly speaking, is constraints are used to rule out potential solutions that don’t exhibit a specific property. For instance, constraints can be used to ensure that specific planning units are selected in the solution for prioritization (using add_locked_in_constraints) or not selected in the solution for prioritization (using add_locked_out_constraints). On the other hand, penalties are combined with the objective of a problem, with a penalty factor, and the overall objective of the problem then becomes to minimize (or maximize) the primary objective function and the penalty function. For example, penalties can be added to a problem to penalize solutions that are excessively fragmented (using add_boundary_penalties). These penalties have a penalty argument that specifies the relative importance of having spatially clustered solutions. When the argument to penalty is high, then solutions which are less fragmented are valued more highly—even if they cost more—and when the argument to penalty is low, then the solutions which are more fragmented are valued less highly. After building a conservation problem, it can then be solved to obtain a solution (or portfolio of solutions if desired). The solution is returned in the same format as the planning unit data used to construct the problem. This means that if raster or shapefile / vector data was used when initializing the problem, then the solution will also be in raster or shapefile / vector data. This can be very helpful when it comes to interpreting and visualizing solutions because it means that the solution data does not first have to be merged with spatial data before they can be plotted on a map. 3.6 Usage Here we will provide an introduction to using the prioritizr R package to build and solve a conservation planning problem. Please note that we will not discuss conservation planning with multiple zones in this vignette, for more information on working with multiple management zones please see the zones vignette. First, we will load the prioritizr package. # load package library(prioritizr) # set default options for printing tabular data options(tibble.width = Inf) 3.6.1 Data Now we will load some built-in data sets that are distributed with the prioritizr R package. This package contains several different planning unit data sets. To provide a comprehensive overview of the different ways that we can initialize a conservation planning problem, we will load each of them. First, we will load the raster planning unit data (sim_pu_raster). Here, the planning units are represented as a raster (i.e. a RasterLayer object) and each pixel corresponds to the spatial extent of each panning unit. The pixel values correspond to the acquisition costs of each planning unit. # load raster planning unit data data(sim_pu_raster) # print description of the data print(sim_pu_raster) ## class : RasterLayer ## dimensions : 10, 10, 100 (nrow, ncol, ncell) ## resolution : 0.1, 0.1 (x, y) ## extent : 0, 1, 0, 1 (xmin, xmax, ymin, ymax) ## crs : NA ## source : memory ## names : layer ## values : 190.1328, 215.8638 (min, max) # plot the data plot(sim_pu_raster) Secondly, we will load one of the spatial vector planning unit data sets (sim_pu_polygons). Here, each polygon (i.e. feature using ArcGIS terminology) corresponds to a different planning unit. This data set has an attribute table that contains additional information about each polygon. Namely, the cost field (column) in the attribute table contains the acquisition cost for each planning unit. # load polygon planning unit data data(sim_pu_polygons) # print first six rows of attribute table head(sim_pu_polygons@data) ## cost locked_in locked_out ## 1 215.8638 FALSE FALSE ## 2 212.7823 FALSE FALSE ## 3 207.4962 FALSE FALSE ## 4 208.9322 FALSE TRUE ## 5 214.0419 FALSE FALSE ## 6 213.7636 FALSE FALSE # plot the planning units spplot(sim_pu_polygons, zcol = &quot;cost&quot;) Thirdly, we will load some planning unit data stored in tabular format (i.e. data.frame format). For those familiar with Marxan or dealing with very large conservation planning problems (&gt; 10 million planning units), it may be useful to work with data in this format because it does not contain any spatial information which will reduce computational burden. When using tabular data to initialize conservation planning problems, the data must follow the conventions used by Marxan. Specifically, each row in the planning unit table must correspond to a different planning unit. The table must also have an “id” column to provide a unique integer identifier for each planning unit, and it must also have a column that indicates the cost of each planning unit. For more information, please see the official Marxan documentation. # specify file path for planning unit data pu_path &lt;- system.file(&quot;extdata/input/pu.dat&quot;, package = &quot;prioritizr&quot;) # load in the tabular planning unit data # note that we use the data.table::fread function, as opposed to the read.csv # function, because it is much faster pu_dat &lt;- data.table::fread(pu_path, data.table = FALSE) # preview first six rows of the tabular planning unit data # note that it has some extra columns other than id and cost as per the # Marxan format head(pu_dat) ## id cost status xloc yloc ## 1 3 0.0 0 1116623 -4493479 ## 2 30 752727.5 3 1110623 -4496943 ## 3 56 3734907.5 0 1092623 -4500408 ## 4 58 1695902.1 0 1116623 -4500408 ## 5 84 3422025.6 0 1098623 -4503872 ## 6 85 17890758.4 0 1110623 -4503872 Finally, we will load data showing the spatial distribution of the conservation features. Our conservation features (sim_features) are represented as a stack of raster objects (i.e. a RasterStack object) where each layer corresponds to a different feature (e.g. a multi-band GeoTIFF where each band corresponds to a different feature). The pixel values in each layer correspond to the amount of suitable habitat available in a given planning unit. Note that our planning unit raster layer and our conservation feature stack have exactly the same spatial properties (i.e. resolution, extent, coordinate reference system) so their pixels line up perfectly. # load feature data data(sim_features) # plot the distribution of suitable habitat for each feature plot(sim_features, main = paste(&quot;Feature&quot;, seq_len(nlayers(sim_features))), nr = 2, box = FALSE, axes = FALSE) 3.6.2 Initialize a problem After having loaded our planning unit and feature data, we will now try initializing the some conservation planning problems. There are a lot of different ways to initialize a conservation planning problem, so here we will just showcase a few of the more commonly used methods. For an exhaustive description of all the ways you can initialize a conservation problem, see the help file for the problem function (which you can open using the code ?problem). First off, we will initialize a conservation planning problem using the raster data. # create problem p1 &lt;- problem(sim_pu_raster, sim_features) # print problem print(p1) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: none ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default # print number of planning units number_of_planning_units(p1) ## [1] 90 # print number of features number_of_features(p1) ## [1] 5 Generally, we recommend initializing problems using raster data where possible. This is because the problem function needs to calculate the amount of each feature in each planning unit, and by providing both the planning unit and feature data in raster format with the same spatial resolution, extents, and coordinate systems, this means that the problem function does not need to do any geo-processing behind the scenes. But sometimes we can’t use raster planning unit data because our planning units aren’t equal-sized grid cells. So, below is an example showing how we can initialize a conservation planning problem using planning units that are formatted as spatial vector data. Note that if we had pre-computed the amount of each feature in each planning unit and stored the data in the attribute table, we could pass in the names of the columns as an argument to the problem function. # create problem with spatial vector data # note that we have to specify which column in the attribute table contains # the cost data p2 &lt;- problem(sim_pu_polygons, sim_features, cost_column = &quot;cost&quot;) # print problem print(p2) ## Conservation Problem ## planning units: SpatialPolygonsDataFrame (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: none ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default We can also initialize a conservation planning problem using tabular planning unit data (i.e. a data.frame). Since the tabular planning unit data does not contain any spatial information, we also have to provide the feature data in tabular format (i.e. a data.frame) and data showing the amount of each feature in each planning unit in tabular format (i.e. a data.frame). The feature data must have an “id” column containing a unique integer identifier for each feature, and the planning unit by feature data must contain the following three columns: “pu” corresponding to the planning unit identifiers, “species” corresponding to the feature identifiers, and “amount” showing the amount of a given feature in a given planning unit. # set file path for feature data spec_path &lt;- system.file(&quot;extdata/input/spec.dat&quot;, package = &quot;prioritizr&quot;) # load in feature data spec_dat &lt;- data.table::fread(spec_path, data.table = FALSE) # print first six rows of the data # note that it contains extra columns head(spec_dat) ## id prop spf name ## 1 10 0.3 1 bird1 ## 2 11 0.3 1 nvis2 ## 3 12 0.3 1 nvis8 ## 4 13 0.3 1 nvis9 ## 5 14 0.3 1 nvis14 ## 6 15 0.3 1 nvis20 # set file path for planning unit vs. feature data puvspr_path &lt;- system.file(&quot;extdata/input/puvspr.dat&quot;, package = &quot;prioritizr&quot;) # load in planning unit vs feature data puvspr_dat &lt;- data.table::fread(puvspr_path, data.table = FALSE) # print first six rows of the data head(puvspr_dat) ## species pu amount ## 1 26 56 1203448.84 ## 2 26 58 451670.10 ## 3 26 84 680473.75 ## 4 26 85 97356.24 ## 5 26 86 78034.76 ## 6 26 111 4783274.17 # create problem p3 &lt;- problem(pu_dat, spec_dat, cost_column = &quot;cost&quot;, rij = puvspr_dat) # print problem print(p3) ## Conservation Problem ## planning units: data.frame (1751 units) ## cost: min: 0, max: 41569219.38232 ## features: bird1, nvis2, nvis8, ... (17 features) ## objective: none ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default For more information on initializing problems, please see the help page for the problem function (which you can open using the code ?problem). Now that we have initialized a conservation planning problem, we will show you how you can customize it to suit the exact needs of your conservation planning scenario. Although we initialized the conservation planning problems using several different methods, moving forward, we will only use raster-based planning unit data to keep things simple. 3.6.3 Add an objective The next step is to add an objective to the problem. A problem objective is used to specify the primary goal of the problem (i.e. the quantity that is to be maximized or minimized). All conservation planning problems involve minimizing or maximizing some kind of objective. For instance, we might require a solution that conserves enough habitat for each species while minimizing the overall cost of the reserve network. Alternatively, we might require a solution that maximizes the number of conserved species while ensuring that the cost of the reserve network does not exceed the budget. Please note that objectives are added in the same way regardless of the type of data used to initialize the problem. The prioritizr R package supports a variety of different objective functions. Minimum set objective: Minimize the cost of the solution whilst ensuring that all targets are met (Rodrigues et al. 2000). This objective is similar to that used in Marxan (Ball et al. 2009). For example, we can add a minimum set objective to a problem using the following code. # create a new problem that has the minimum set objective p3 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() # print the problem print(p3) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Maximum cover objective: Represent at least one instance of as many features as possible within a given budget (Church et al. 1996). # create a new problem that has the maximum coverage objective and a budget # of 5000 p4 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_max_cover_objective(5000) # print the problem print(p4) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Maximum coverage objective [budget (5000)] ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Maximum features objective: Fulfill as many targets as possible while ensuring that the cost of the solution does not exceed a budget (inspired by Cabeza &amp; Moilanen 2001). This object is similar to the maximum cover objective except that we have the option of later specifying targets for each feature. In practice, this objective is more useful than the maximum cover objective because features often require a certain amount of area for them to persist and simply capturing a single instance of habitat for each feature is generally unlikely to enhance their long-term persistence. # create a new problem that has the maximum features objective and a budget # of 5000 p5 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_max_features_objective(budget = 5000) # print the problem print(p5) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Maximum representation objective [budget (5000)] ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Minimum shortfall objective: Minimize the shortfall for as many targets as possible while ensuring that the cost of the solution does not exceed a budget. In practice, this objective useful when there is a large amount of left-over budget when using the maximum feature representation objective and the remaining funds need to be allocated to places that will enhance the representation of features with unmet targets. # create a new problem that has the minimum shortfall objective and a budget # of 5000 p6 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_shortfall_objective(budget = 5000) # print the problem print(p6) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum shortfall objective [budget (5000)] ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Maximum phylogenetic diversity objective: Maximize the phylogenetic diversity of the features represented in the solution subject to a budget (inspired by Faith 1992; Rodrigues &amp; Gaston 2002). This objective is similar to the maximum features objective except that emphasis is placed on protecting features which are associated with a diverse range of evolutionary histories. The prioritizr R package contains a simulated phylogeny that can be used with the simulated feature data (sim_phylogny). # load simulated phylogeny data data(sim_phylogeny) # create a new problem that has the maximum phylogenetic diversity # objective and a budget of 5000 p7 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_max_phylo_div_objective(budget = 5000, tree = sim_phylogeny) # print the problem print(p7) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Phylogenetic diversity objective [budget (5000)] ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Maximum phylogenetic endemism objective: Maximize the phylogenetic endemism of the features represented in the solution subject to a budget (inspired by Faith 1992; Rodrigues &amp; Gaston 2002; Rosauer et al. 2009). This objective is similar to the maximum phylogenetic diversity except that emphasis is placed conserving features that are associated with geographically restricted periods of evolutionary history rather than a diverse range of evolutionary histories. # load simulated phylogeny data data(sim_phylogeny) # create a new problem that has the maximum phylogenetic diversity # objective and a budget of 5000 p8 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_max_phylo_end_objective(budget = 5000, tree = sim_phylogeny) # print the problem print(p8) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Phylogenetic endemism objective [budget (5000)] ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Maximum utility objective: Secure as much of the features as possible without exceeding a budget. This objective is functionally equivalent to selecting the planning units with the greatest amounts of each feature (e.g. species richness). Generally, we don’t encourage the use of this objective because it will only rarely identify complementary solutions—solutions which adequately conserve a range of different features—except perhaps to explore trade-offs or provide a baseline solution with which to compare other solutions. # create a new problem that has the maximum utility objective and a budget # of 5000 p9 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_max_utility_objective(budget = 5000) # print the problem print(p9) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Maximum utility objective [budget (5000)] ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default 3.6.4 Add targets Most conservation planning problems require targets. Targets are used to specify the minimum amount or proportion of a feature’s distribution that needs to be protected in the solution. For example, we may want to develop a reserve network that will secure 20% of the distribution for each feature for minimal cost. There are four ways for specifying targets in the prioritizr R package: Absolute targets: Targets are expressed as the total amount of each feature in the study area that need to be secured. For example, if we had binary feature data that showed the absence or presence of suitable habitat across the study area, we could set an absolute target as 5 to mean that we require 5 planning units with suitable habitat in the solution. # create a problem with targets which specify that the solution must conserve # a need a sum total of 3 units of suitable habitat for each feature p10 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_absolute_targets(3) # print problem print(p10) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Absolute targets [targets (min: 3, max: 3)] ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Relative targets: Targets are set as a proportion (between 0 and 1) of the total amount of each feature in the study area. For example, if we had binary feature data and the feature occupied a total of 20 planning units in the study area, we could set a relative target of 50 % to specify that the solution must secure 10 planning units for the feature. We could alternatively specify an absolute target of 10 to achieve the same result, but sometimes proportions are easier to work with. # create a problem with the minimum set objective and relative targets of 10 % # for each feature p11 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) # print problem print(p11) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default # create a problem with targets which specify that we need 10 % of the habitat # for the first feature, 15 % for the second feature, 20 % for the third feature # 25 % for the fourth feature and 30 % of the habitat for the fifth feature targets &lt;- c(0.1, 0.15, 0.2, 0.25, 0.3) p12 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(targets) # print problem print(p12) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.3)] ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Log-linear targets: Targets are expressed using scaling factors and log-linear interpolation. This method for specifying targets is commonly used for global prioritization analyses (Rodrigues et al. 2004). # create problem with added log-linear targets p13 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_loglinear_targets(10, 0.9, 100, 0.2) # print problem print(p13) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Absolute targets [targets (min: 17.290505409161, max: 21.5906174426385)] ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Manual targets: Targets are manually specified. This is only really recommended for advanced users or problems that involve multiple management zones. See the zones vignette for more information on these targets. As with the functions for specifying the objective of a problem, if we try adding multiple targets to a problem, only the most recently added set of targets are used. 3.6.5 Add constraints A constraint can be added to a conservation planning problem to ensure that all solutions exhibit a specific property. For example, they can be used to make sure that all solutions select a specific planning unit or that all selected planning units in the solution follow a certain configuration. The following constraints can be added to conservation planning problems in the prioritizr R package. Locked in constraints: Add constraints to ensure that certain planning units are prioritized in the solution. For example, it may be desirable to lock in planning units that are inside existing protected areas so that the solution fills in the gaps in the existing reserve network. # create problem with constraints which specify that the first planning unit # must be selected in the solution p14 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_locked_in_constraints(1) # print problem print(p14) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;Locked in planning units [1 locked units]&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Locked out constraints: Add constraints to ensure that certain planning units are not prioritized in the solution. For example, it may be useful to lock out planning units that have been degraded and are not suitable for conserving species. # create problem with constraints which specify that the second planning unit # must not be selected in the solution p15 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_locked_out_constraints(2) # print problem print(p15) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;Locked out planning units [1 locked units]&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Neighbor constraints: Add constraints to a conservation problem to ensure that all selected planning units have at least a certain number of neighbors. # create problem with constraints which specify that all selected planning units # in the solution must have at least 1 neighbor p16 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_neighbor_constraints(1) # print problem print(p16) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;Neighbor constraint [number of neighbors (1), zones]&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Contiguity constraints: Add constraints to a conservation problem to ensure that all selected planning units are spatially connected to each other and form spatially contiguous unit. # create problem with constraints which specify that all selected planning units # in the solution must form a single contiguous unit p17 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_contiguity_constraints() # print problem print(p17) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;Contiguity constraints [apply constraints? (1), zones]&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Feature contiguity constraints: Add constraints to ensure that each feature is represented in a contiguous unit of dispersible habitat. These constraints are a more advanced version of those implemented in the add_contiguity_constraints function, because they ensure that each feature is represented in a contiguous unit and not that the entire solution should form a contiguous unit. # create problem with constraints which specify that the planning units used # to conserve each feature must form a contiguous unit p18 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_feature_contiguity_constraints() # print problem print(p18) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;Feature contiguity constraints [apply constraints? (1), layer.1 zones, layer.2 zones, layer.3 zones, layer.4 zones, layer.5 zones]&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Mandatory allocation constraints: Add constraints to ensure that every planning unit is allocated to a management zone in the solution. Please note that this function can only be used with problems that contain multiple zones. For more information on problems with multiple zones and an example using this function, see the Management Zones vignette. In particular, The add_locked_in_constraints and add_locked_out_constraints functions are incredibly useful for real-world conservation planning exercises, so it’s worth pointing out that there are several ways we can specify which planning units should be locked in or out of the solutions. If we use raster planning unit data, we can also use raster data to specify which planning units should be locked in our locked out. # load data to lock in or lock out planning units data(sim_locked_in_raster) data(sim_locked_out_raster) # plot the locked data plot(stack(sim_locked_in_raster, sim_locked_out_raster), main = c(&quot;Locked In&quot;, &quot;Locked Out&quot;)) # create a problem using raster planning unit data and use the locked raster # data to lock in some planning units and lock out some other planning units p19 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_locked_in_constraints(sim_locked_in_raster) %&gt;% add_locked_out_constraints(sim_locked_out_raster) # print problem print(p19) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;Locked in planning units [10 locked units] ## Locked out planning units [10 locked units]&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default If our planning unit data are in a spatial vector format (similar to the sim_pu_polygons data) or a tabular format (similar to pu_dat), we can use the field names in the data to refer to which planning units should be locked in and / or out. For example, the sim_pu_polygons object has TRUE / FALSE values in the “locked_in” field which indicate which planning units should be selected in the solution. We could use the data in this field to specify that those planning units with TRUE values should be locked in using the following methods. # preview first six rows of the attribute table for sim_pu_polygons head(sim_pu_polygons@data) ## cost locked_in locked_out ## 1 215.8638 FALSE FALSE ## 2 212.7823 FALSE FALSE ## 3 207.4962 FALSE FALSE ## 4 208.9322 FALSE TRUE ## 5 214.0419 FALSE FALSE ## 6 213.7636 FALSE FALSE # specify locked in data using the field name p20 &lt;- problem(sim_pu_polygons, sim_features, cost_column = &quot;cost&quot;) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_locked_in_constraints(&quot;locked_in&quot;) # print problem print(p20) ## Conservation Problem ## planning units: SpatialPolygonsDataFrame (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;Locked in planning units [10 locked units]&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default # specify locked in data using the values in the field p21 &lt;- problem(sim_pu_polygons, sim_features, cost_column = &quot;cost&quot;) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_locked_in_constraints(which(sim_pu_polygons$locked_in)) # print problem print(p21) ## Conservation Problem ## planning units: SpatialPolygonsDataFrame (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;Locked in planning units [10 locked units]&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default 3.6.6 Add penalties We can also add penalties to a problem to favor or penalize solutions according to a secondary objective. Unlike the constraint functions, these functions will add extra information to the objective function of the optimization function to penalize solutions that do not exhibit specific characteristics. For example, penalties can be added to a problem to avoid highly fragmented solutions at the expense of accepting slightly more expensive solutions. All penalty functions have a penalty argument that controls the relative importance of the secondary penalty function compared to the primary objective function. It is worth noting that incredibly low or incredibly high penalty values—relative to the main objective function—can cause problems to take a very long time to solve, so when trying out a range of different penalty values it can be helpful to limit the solver to run for a set period of time. The prioritizr R package currently offers only two methods for adding penalties to a conservation planning problem. Boundary penalties: Add penalties to penalize solutions that are excessively fragmented. These penalties are similar to those used in Marxan (Ball et al. 2009; Beyer et al. 2016). # create problem with penalties that penalize fragmented solutions with a # penalty factor of 0.01 p22 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_boundary_penalties(penalty = 0.01) # print problem print(p22) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;Boundary penalties [edge factor (min: 0.5, max: 0.5), penalty (0.01), zones]&gt; ## portfolio: default ## solver: default Connectivity penalties: Add penalties to favor solutions that select combinations of planning units with high connectivity between them. These penalties are similar to those used in Marxan with Zones (Watts et al. 2009; Beyer et al. 2016). This function supports both symmetric and asymmetric connectivities among planning units. # create problem with penalties that favor combinations of planning units with # high connectivity, here we will use only the first four layers in # sim_features for the features and we will use the fifth layer in sim_features # to represent the connectivity data, where the connectivity_matrix function # will create a matrix showing the average strength of connectivity between # adjacent planning units using the data in the fifth layer of sim_features p23 &lt;- problem(sim_pu_raster, sim_features[[1:4]]) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_boundary_penalties(penalty = 5, data = connectivity_matrix(sim_pu_raster, sim_features[[5]])) # print problem print(p23) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, layer.4 (4 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;Boundary penalties [edge factor (min: 0.5, max: 0.5), penalty (5), zones]&gt; ## portfolio: default ## solver: default Linear penalties: Add penalties to penalize solutions that select planning units according to a certain variable (e.g. anthropogenic pressure). # create data for penalizing planning units pen_raster &lt;- simulate_cost(sim_pu_raster) # create problem with penalties that penalize solutions that select # planning units with high values in the pen_raster object, # here we will use a penalty value of 5 to indicate the trade-off (scaling) # between the penalty values (in the sim_pu_raster) and the main objective # (i.e. the cost of the solution) p24 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_linear_penalties(penalty = 5, data = pen_raster) # print problem print(p24) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;Linear penalties [penalty (5)]&gt; ## portfolio: default ## solver: default 3.6.7 Add the decision types Conservation planning problems involve making decisions on how planning units will be managed. These decisions are then associated with management actions (e.g. turning a planning unit into a protected area). The type of decision describes how the action is applied to planning units. For instance, the default decision-type is a binary decision type, meaning that we are either selecting or not selecting planning units for management. The prioritizr R package currently offers the following types of decisions for customizing problems. Binary decisions: Add a binary decision to a conservation planning problem. This is the classic decision of either prioritizing or not prioritizing a planning unit. Typically, this decision has the assumed action of buying the planning unit to include in a protected area network. If no decision is added to a problem object, then this decision class will be used by default. # add binary decisions to a problem p25 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_binary_decisions() # print problem print(p25) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: Binary decision ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Proportion decisions: Add a proportion decision to a problem. This is a relaxed decision where a part of a planning unit can be prioritized, as opposed to the default of the entire planning unit. Typically, this decision has the assumed action of buying a fraction of a planning unit to include in a protected area network. Generally, problems can be solved much faster with proportion-type decisions than binary-type decisions, so they can be very useful when commercial solvers are not available. # add proportion decisions to a problem p26 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_proportion_decisions() # print problem print(p26) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: Proportion decision ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Semi-continuous decisions: Add a semi-continuous decision to a problem. This decision is similar to proportion decisions except that it has an upper bound parameter. By default, the decision can range from prioritizing none (0%) to all (100%) of a planning unit. However, a upper bound can be specified to ensure that at most only a fraction (e.g. 80%) of a planning unit can be purchased. This type of decision may be useful when it is not practical to conserve the entire area indicated by a planning unit. # add semi-continuous decisions to a problem, where we can only manage at most # 50 % of the area encompassed by a planning unit p27 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_semicontinuous_decisions(0.5) # print problem print(p27) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: Semicontinuous decision [upper limit (0.5)] ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default 3.6.8 Add a solver Next, after specifying the mathematical formulation that underpins your conservation planning problem, you can specify how the problem should be solved. If you do not specify this information, the prioritizr R package will automatically use the best solver currently installed on your system with some reasonable defaults. We strongly recommend installing the Gurobi software suite and the gurobi R package to solve problems, and for more information on this topic please refer to the Gurobi Installation Guide. Currently, the prioritizr R package only supports three different solvers. Gurobi solver: Gurobi is a state of the art commercial optimization software. It is by far the fastest of the solvers that can be used to solve conservation problems. However, it is not freely available. That said, special licenses are available to academics at no cost. # create a problem and specify that Gurobi should be used to solve the problem # and specify an optimality gap of zero to obtain the optimal solution p28 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_binary_decisions() %&gt;% add_gurobi_solver(gap = 0) # print problem print(p28) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: Binary decision ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: Gurobi [first_feasible (0), gap (0), numeric_focus (0), presolve (2), threads (1), time_limit (2147483647), verbose (1)] IBM CPLEX solver: IBM CPLEX is a commercial optimization software. It is faster than the open source solvers available for generating prioritizations (see below), however, it is not freely available. Similar to the Gurobi software, special licenses are available to academics at no cost. # create a problem and specify that IBM CPLEX should be used to solve the # problem and specify an optimality gap of zero to obtain the optimal solution # p29 &lt;- problem(sim_pu_raster, sim_features) %&gt;% # add_min_set_objective() %&gt;% # add_relative_targets(0.1) %&gt;% # add_binary_decisions() %&gt;% # add_cplex_solver(gap = 0) # # # print problem # print(p29) Rsymphony solver: SYMPHONY is an open-source integer programming solver that is part of the Computational Infrastructure for Operations Research (COIN-OR) project, an initiative to promote development of open-source tools for operations research. The Rsymphony R package provides an interface to COIN-OR and is available on The Comprehensive R Archive Network (CRAN). # create a problem and specify that Rsymphony should be used to solve the # problem and specify an optimality gap of zero to obtain the optimal solution # p30 &lt;- problem(sim_pu_raster, sim_features) %&gt;% # add_min_set_objective() %&gt;% # add_relative_targets(0.1) %&gt;% # add_binary_decisions() %&gt;% # add_rsymphony_solver(gap = 0) # # # print problem # print(p30) lpsymphony solver: The lpsymphony R package provides a different interface to the COIN-OR software suite. This package may be easier to install on Windows and Mac OSX operating systems than the Rsymphony R package. Unlike the Rsymphony R package, the lpsymphony R package is distributed through Bioconductor. # create a problem and specify that lpsymphony should be used to solve the # problem and specify an optimality gap of zero to obtain the optimal solution # p31 &lt;- problem(sim_pu_raster, sim_features) %&gt;% # add_min_set_objective() %&gt;% # add_relative_targets(0.1) %&gt;% # add_binary_decisions() %&gt;% # add_lpsymphony_solver(gap = 0) # # # print problem # print(p31) 3.6.9 Add a portfolio Many conservation planning exercises require a portfolio of solutions. For example, real-world exercises can involve presenting decision makers with a range of near-optimal decisions. Additionally, the number of times that different planning units are selected in different solutions can provide insight into their relative importance. The following methods are available for generating a portfolio of solutions. Extra portfolio: Generate a portfolio of solutions by storing feasible solutions found during the optimization process. Note that this method requires that the Gurobi optimization software is used to generate solutions. # create a problem and specify that a portfolio should be created using # extra solutions found while solving the problem # p32 &lt;- problem(sim_pu_raster, sim_features) %&gt;% # add_min_set_objective() %&gt;% # add_relative_targets(0.1) %&gt;% # add_binary_decisions() %&gt;% # add_extra_portfolio() # # # print problem # print(p32) Top portfolio: Generate a portfolio of solutions by finding a pre-specified number of solutions that are closest to optimality (i.e the top solutions). Note that this method requires that the Gurobi optimization software is used to generate solutions. # create a problem and specify that a portfolio should be created using # the top five solutions # p33 &lt;- problem(sim_pu_raster, sim_features) %&gt;% # add_min_set_objective() %&gt;% # add_relative_targets(0.1) %&gt;% # add_binary_decisions() %&gt;% # add_top_portfolio(number_solutions = 5) # # # print problem # print(p33) Gap portfolio: Generate a portfolio of solutions by finding a certain number of solutions that are all within a pre-specified optimality gap. This method is especially useful for generating multiple solutions that can used be to calculate selection frequencies (similar to Marxan). Note that this method requires that the Gurobi optimization software is used to generate solutions. # create a problem and specify that a portfolio should be created by # finding five solutions within 10% of optimality # p34 &lt;- problem(sim_pu_raster, sim_features) %&gt;% # add_min_set_objective() %&gt;% # add_relative_targets(0.1) %&gt;% # add_binary_decisions() %&gt;% # add_gap_portfolio(number_solutions = 5, pool_gap = 0.2) # # # print problem # print(p34) Cuts portfolio: Generate a portfolio of distinct solutions within a pre-specified optimality gap. This method is only recommended if the Gurobi optimization solver is not available. # create a problem and specify that a portfolio containing 10 solutions # should be created using using Bender&#39;s cuts # p35 &lt;- problem(sim_pu_raster, sim_features) %&gt;% # add_min_set_objective() %&gt;% # add_relative_targets(0.1) %&gt;% # add_binary_decisions() %&gt;% # add_cuts_portfolio(number_solutions = 10) # # # print problem # print(p35) Shuffle portfolio: Generate a portfolio of solutions by randomly reordering the data prior to attempting to solve the problem. If the Gurobi optimization solver is not available, this method is the fastest method for generating a set number of solutions within a specified distance from optimality. # create a problem and specify a portfolio should be created that contains # 10 solutions and that any duplicate solutions should not be removed # p36 &lt;- problem(sim_pu_raster, sim_features) %&gt;% # add_min_set_objective() %&gt;% # add_relative_targets(0.1) %&gt;% # add_binary_decisions() %&gt;% # add_shuffle_portfolio(number_solutions = 10, remove_duplicates = FALSE) # # # print problem # print(p36) 3.6.10 Solve the problem Finally, after formulating our conservation planning problem and specifying how the problem should be solved, we can use the solve function to obtain a solution. Note that the solver will typically print out some information describing the size of the problem and report its progress when searching for a suitable solution. # formulate the problem p37 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_boundary_penalties(penalty = 500, edge_factor = 0.5) %&gt;% add_binary_decisions() # solve the problem (using the default solver) s37 &lt;- solve(p37) ## Gurobi Optimizer version 9.1.1 build v9.1.1rc0 (mac64) ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ## Optimize a model with 293 rows, 234 columns and 1026 nonzeros ## Model fingerprint: 0xbd38144b ## Variable types: 0 continuous, 234 integer (234 binary) ## Coefficient statistics: ## Matrix range [2e-01, 1e+00] ## Objective range [1e+02, 4e+02] ## Bounds range [1e+00, 1e+00] ## RHS range [3e+00, 8e+00] ## Found heuristic solution: objective 20287.196992 ## Found heuristic solution: objective 3087.9617505 ## Presolve time: 0.00s ## Presolved: 293 rows, 234 columns, 1026 nonzeros ## Variable types: 0 continuous, 234 integer (234 binary) ## Presolved: 293 rows, 234 columns, 1026 nonzeros ## ## ## Root relaxation: objective 2.265862e+03, 218 iterations, 0.00 seconds ## ## Nodes | Current Node | Objective Bounds | Work ## Expl Unexpl | Obj Depth IntInf | Incumbent BestBd Gap | It/Node Time ## ## 0 0 2265.86242 0 234 3087.96175 2265.86242 26.6% - 0s ## H 0 0 2920.9854189 2265.86242 22.4% - 0s ## 0 0 2327.26806 0 232 2920.98542 2327.26806 20.3% - 0s ## 0 0 2368.37316 0 226 2920.98542 2368.37316 18.9% - 0s ## 0 0 2376.91951 0 223 2920.98542 2376.91951 18.6% - 0s ## 0 0 2376.91951 0 223 2920.98542 2376.91951 18.6% - 0s ## H 0 0 2910.0202492 2376.91951 18.3% - 0s ## H 0 0 2676.6543486 2376.91951 11.2% - 0s ## 0 2 2377.44918 0 223 2676.65435 2377.44918 11.2% - 0s ## H 27 27 2676.6537993 2377.44918 11.2% 16.9 0s ## H 56 40 2676.6531808 2388.87827 10.8% 16.2 0s ## ## Cutting planes: ## Gomory: 3 ## ## Explored 57 nodes (1397 simplex iterations) in 0.15 seconds ## Thread count was 1 (of 8 available processors) ## ## Solution count 5: 2676.65 2910.02 2920.99 ... 20287.2 ## ## Optimal solution found (tolerance 1.00e-01) ## Best objective 2.676653180861e+03, best bound 2.413625263266e+03, gap 9.8267% # plot solution plot(s37, col = c(&quot;grey90&quot;, &quot;darkgreen&quot;), main = &quot;Solution&quot;, xlim = c(-0.1, 1.1), ylim = c(-0.1, 1.1)) We can plot this solution because the planning unit input data are spatially referenced in a raster format. The output format will always match the planning unit data used to initialize the problem. For example, the solution to a problem with planning units in a spatial vector (shapefile) format would also be in a spatial vector format. Similarly, if the planning units were in a tabular format (i.e. data.frame), the solution would also be returned in a tabular format. We can also extract attributes from the solution that describe the quality of the solution and the optimization process. # extract the objective (numerical value being minimized or maximized) print(attr(p37, &quot;objective&quot;)) ## NULL # extract time spent solving solution print(attr(p37, &quot;runtime&quot;)) ## NULL # extract state message from the solver that describes why this specific # solution was returned print(attr(p37, &quot;status&quot;)) ## NULL 3.6.11 Marxan problems Although users are encouraged to build and tailor conservation planning problems to suit their own needs using the problem function, sometimes it just simply easier to use a more familiar formulation. The marxan_problem function is provided as a convenient wrapper for building and solving Marxan-style conservation problems. If users already have their conservation planning data formatted for use with Marxan, this function can also read Marxan data files and solve the Marxan-style problems using exact algorithm solvers. Please note that problems built using the marxan_problem function are still solved the same way as a problem initialized using the problem function, and therefore still require the installation of one of the solver packages. Here is a short example showing how the marxan_problem function can be used to read Marxan input files and the solve function can be used to solve the problem. # set file path for Marxan input file minput &lt;- system.file(&quot;extdata/input.dat&quot;, package = &quot;prioritizr&quot;) # read Marxan input file mp &lt;- marxan_problem(minput) # print problem print(mp) ## Conservation Problem ## planning units: data.frame (1751 units) ## cost: min: 0, max: 41569219.38232 ## features: bird1, nvis2, nvis8, ... (17 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.3, max: 0.3)] ## decisions: default ## constraints: &lt;Locked out planning units [1 locked units] ## Locked in planning units [317 locked units]&gt; ## penalties: &lt;Boundary penalties [edge factor (min: 1, max: 1), penalty (1), zones]&gt; ## portfolio: default ## solver: default # solve the problem ms &lt;- solve(mp) # since the Marxan data was in a tabular format, the solution is also returned # in a tabular format, so we will print the first six rows of the table # containing the solution head(ms) Alternatively, rather then using a Marxan input file to construct the problem, we can manually read in the Marxan data files and input these to the marxan_problem function. # load data pu &lt;- system.file(&quot;extdata/input/pu.dat&quot;, package = &quot;prioritizr&quot;) %&gt;% read.table(sep = &quot;,&quot;, header = TRUE) features &lt;- system.file(&quot;extdata/input/spec.dat&quot;, package = &quot;prioritizr&quot;) %&gt;% read.table(sep = &quot;,&quot;, header = TRUE) bound &lt;- system.file(&quot;extdata/input/bound.dat&quot;, package = &quot;prioritizr&quot;) %&gt;% read.table(sep = &quot;\\t&quot;, header = TRUE) rij &lt;- system.file(&quot;extdata/input/puvspr.dat&quot;, package = &quot;prioritizr&quot;) %&gt;% read.table(sep = &quot;,&quot;, header = TRUE) # build Marxan problem using data.frame objects mp2 &lt;- marxan_problem(x = pu, spec = features, puvspr = rij, bound = bound, blm = 0) # print problem print(mp2) ## Conservation Problem ## planning units: data.frame (1751 units) ## cost: min: 0, max: 41569219.38232 ## features: bird1, nvis2, nvis8, ... (17 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.3, max: 0.3)] ## decisions: default ## constraints: &lt;Locked out planning units [1 locked units] ## Locked in planning units [317 locked units]&gt; ## penalties: &lt;Boundary penalties [edge factor (min: 1, max: 1), penalty (0), zones]&gt; ## portfolio: default ## solver: default 3.6.12 Evaluate the performance of a solution After obtaining a solution to a conservation planning problem, it can be useful to calculate various summary statistics to understand its performance. The following functions are available to summarize a solution: Calculate the number of planning units selected within a solution. # calculate statistic eval_n_summary(p37, s37) ## # A tibble: 1 x 2 ## summary cost ## &lt;chr&gt; &lt;dbl&gt; ## 1 overall 10 Calculate the total cost of a solution. # calculate statistic eval_cost_summary(p37, s37) ## # A tibble: 1 x 2 ## summary cost ## &lt;chr&gt; &lt;dbl&gt; ## 1 overall 2002. Calculate how well features are represented by a solution. This function can be used for problems that are built using targets and those that are not built using targets. # calculate statistics eval_feature_representation_summary(p37, s37) ## # A tibble: 5 x 5 ## summary feature total_amount absolute_held relative_held ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 overall layer.1 83.3 8.96 0.108 ## 2 overall layer.2 31.2 3.19 0.102 ## 3 overall layer.3 72.0 7.56 0.105 ## 4 overall layer.4 42.7 4.32 0.101 ## 5 overall layer.5 56.7 5.93 0.105 Calculate how well feature representation targets are met by a solution. This function can only be used with problems contain targets. # calculate statistics eval_target_coverage_summary(p37, s37) ## # A tibble: 5 x 9 ## feature met total_amount absolute_target absolute_held absolute_shortfall relative_target relative_held ## &lt;chr&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 layer.1 TRUE 83.3 8.33 8.96 0 0.1 0.108 ## 2 layer.2 TRUE 31.2 3.12 3.19 0 0.1 0.102 ## 3 layer.3 TRUE 72.0 7.20 7.56 0 0.1 0.105 ## 4 layer.4 TRUE 42.7 4.27 4.32 0 0.1 0.101 ## 5 layer.5 TRUE 56.7 5.67 5.93 0 0.1 0.105 ## relative_shortfall ## &lt;dbl&gt; ## 1 0 ## 2 0 ## 3 0 ## 4 0 ## 5 0 Calculate the exposed boundary length (perimeter) associated with a solution. # calculate statistic eval_boundary_summary(p37, s37) ## # A tibble: 1 x 2 ## summary boundary ## &lt;chr&gt; &lt;dbl&gt; ## 1 overall 1.35 Calculate the connectivity held within a solution. # calculate statistic # here we use the raster data for the first feature as an example # to parametrize pair-wise connectivity between different planning units eval_connectivity_summary( p37, s37, data = connectivity_matrix(sim_pu_raster, sim_features[[1]])) ## # A tibble: 1 x 2 ## summary connectivity ## &lt;chr&gt; &lt;dbl&gt; ## 1 overall 1.80 3.6.13 Importance (irreplaceability) Conservation plans can take a long time to implement. Since funding availability and habitat quality can decline over time, it is critical that the most important places in a prioritization are scheduled for protection as early as possible. For instance, some planning units in a solution might contain many rare species which do not occur in any other planning units. Alternatively, some planning units might offer an especially high return on investment that reduces costs considerably. As a consequence, conservation planners often need information on which planning units selected in a prioritization are most important to the overall success of the prioritization. To achieve this, conservation planners can use importance (irreplaceability) scores for each planning unit selected in a solution. The prioritizr R package offers multiple methods for assessing importance. These includes scores calculated based on replacement costs [eval_replacement_importance(); Cabeza &amp; Moilanen (2006)], Ferrier et al. (2000) (eval_ferrier_importance()), and rarity weighted richness scores [eval_rare_richness_importance(); Williams et al. (1996)]. The replacement cost scores quantify the change in the objective function (e.g. additional costs required to meet feature targets) of the optimal solution if a given planning unit in a solution cannot be acquired. They can (i) account for the cost of different planning units, (ii) account for multiple management zones, (iii) apply to any objective function, and (iv) identify truly irreplaceable planning units (denoted with infinite values). The Ferrier scores quantify the importance of planning units for meeting feature targets. They can only be applied to conservation problems with a minimum set objective and a single zone (i.e. the classic Marxan-type problem). Furthermore—unlike the replacement cost scores—the Ferrier scores provide a score for each feature within each planning unit, providing insight into why certain planning units are more important than other planning units. The rarity weighted richness scores are simply a measure of biological diversity. They do not account for planning costs, multiple management zones, objective functions, or feature targets (or weightings). They merely describe the spatial patterns of biodiversity, and do not account for many of the factors needed to quantify the importance of a planning unit for achieving conservation goals. We recommend using replacement cost scores for small and moderate sized problems (e.g. less than 30,000 planning units) when it is feasible to do so. It can take a very long time to compute replacement cost scores, and so it is simply not feasible to compute these scores for particularly large problems. For moderate and large sized problems (e.g. more than 30,000 planning units), we recommend using the rarity weighted richness scores. Beware, it has been known for decades that such static measures of biodiversity lead to poor conservation plans (Kirkpatrick 1983). Although the Ferrier method is also provided, we do not recommend using this method until it has been verified by a statistical expert. Below we will generate a solution, and then calculate importance scores for the planning units selected in the solution using the three different methods. # formulate the problem p38 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_binary_decisions() # solve the problem s38 &lt;- solve(p38) ## Gurobi Optimizer version 9.1.1 build v9.1.1rc0 (mac64) ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ## Optimize a model with 5 rows, 90 columns and 450 nonzeros ## Model fingerprint: 0x6442bf6e ## Variable types: 0 continuous, 90 integer (90 binary) ## Coefficient statistics: ## Matrix range [2e-01, 9e-01] ## Objective range [2e+02, 2e+02] ## Bounds range [1e+00, 1e+00] ## RHS range [3e+00, 8e+00] ## Found heuristic solution: objective 2337.9617505 ## Presolve time: 0.00s ## Presolved: 5 rows, 90 columns, 450 nonzeros ## Variable types: 0 continuous, 90 integer (90 binary) ## Presolved: 5 rows, 90 columns, 450 nonzeros ## ## ## Root relaxation: objective 1.931582e+03, 12 iterations, 0.00 seconds ## ## Nodes | Current Node | Objective Bounds | Work ## Expl Unexpl | Obj Depth IntInf | Incumbent BestBd Gap | It/Node Time ## ## 0 0 1931.58191 0 4 2337.96175 1931.58191 17.4% - 0s ## H 0 0 1987.3985265 1931.58191 2.81% - 0s ## ## Explored 1 nodes (12 simplex iterations) in 0.00 seconds ## Thread count was 1 (of 8 available processors) ## ## Solution count 2: 1987.4 2337.96 ## ## Optimal solution found (tolerance 1.00e-01) ## Best objective 1.987398526526e+03, best bound 1.931581908865e+03, gap 2.8085% # plot solution plot(s38, col = c(&quot;grey90&quot;, &quot;darkgreen&quot;), main = &quot;Solution&quot;, xlim = c(-0.1, 1.1), ylim = c(-0.1, 1.1)) # calculate replacement cost scores and make the solver quiet rc38 &lt;- p38 %&gt;% add_default_solver(gap = 0, verbose = FALSE) %&gt;% eval_replacement_importance(s38) # plot replacement cost scores plot(rc38, main = &quot;replacement cost&quot;) # calculate Ferrier scores and extract total score fs38 &lt;- eval_ferrier_importance(p38, s38)[[&quot;total&quot;]] # plot Ferrier scores plot(fs38, main = &quot;Ferrier scores&quot;) # calculate rarity weighted richness scores rwr38 &lt;- eval_rare_richness_importance(p38, s38) # plot replacement cost scores plot(rwr38, main = &quot;rarity weighted richness&quot;) Although rarity weighted richness scores can approximate scores derived from the other two methods in certain conservation planning exercises, we can see that the rarity weighted richness scores provide completely different results in this case. 3.7 Conclusion Hopefully, this vignette has provided an informative introduction to the prioritizr R package. For more worked examples using the prioritizr R package, check out the Tasmania and Salt Spring Island vignettes. Perhaps, one of the best ways to learn a new piece of software is to just try it out. Test it, try breaking it, make mistakes, and learn from them. We would recommend trying to build conservation planning problems that resemble those you face in your own work—but using the built-in example data sets. This way you can quickly verify that the problems you build actually mean what you think they mean. For instance, you can try playing around with the targets and see what effect they have on the solutions, or try playing around with penalties and see what effect they have on the solutions. Finally, if you have any questions about using the prioritizr R package or suggestions for improving the prioritizr R package (perhaps addressing some spelling mistakes found whilst reading this vignette?), please file an issue on the package’s online coding repository (https://github.com/prioritizr/prioritizr/issues). 3.8 References "],["running-prioritizr.html", "Chapter 4 Running Prioritizr 4.1 Package work flow 4.2 Usage 4.3 Conclusion", " Chapter 4 Running Prioritizr 4.1 Package work flow The general work flow when using the prioritizr R package starts with creating a new conservation planning problem object using data. Specifically, the problem object should be constructed using data that specify the planning units, biodiversity features, management zones (if applicable), and costs. After creating a new problem object, it can be customized—by adding objectives, penalties, constraints, and other information—to build a precise representation of the conservation planning problem required, and then solved to obtain a solutions. All conservation planning problems require an objective. An objective specifies the property which is used to compare different feasible solutions. Simply put, the objective is the property of the solution which should be maximized or minimized during the optimization process. For instance, with the minimum set objective (specified using add_min_set_objective), we are seeking to minimize the cost of the solution (similar to Marxan). On the other hand, with the maximum coverage objective (specified using add_max_cover_objective), we are seeking to maximize the number of different features represented in the solution. Many objectives require targets (e.g. the minimum set objective). Targets are a specialized set of constraints that relate to the total quantity of each feature secured in the solution (e.g. amount of suitable habitat or number of individuals). In the case of the minimum set objective ( add_min_set_objective), they are used to ensure that solutions secure a sufficient quantity of each feature, and in other objectives, such as the maximum features objective ( add_max_features_objective) they are used to assess whether a feature has been adequately conserved by a candidate solution. Targets can be expressed numerically as the total amount required for a given feature (using add_absolute_targets), or as a proportion of the total amount found in the planning units (using add_relative_targets). Note that not all objectives require targets, and a warning will be thrown if an attempt is made to add targets to a problem with an objective that does not use them. Constraints and penalties can be added to a conservation planning problem to ensure that solutions exhibit a specific property or penalize solutions which don’t exhibit a specific property (respectively). The difference between constraints and penalties, strictly speaking, is constraints are used to rule out potential solutions that don’t exhibit a specific property. For instance, constraints can be used to ensure that specific planning units are selected in the solution for prioritization (using add_locked_in_constraints) or not selected in the solution for prioritization (using add_locked_out_constraints). On the other hand, penalties are combined with the objective of a problem, with a penalty factor, and the overall objective of the problem then becomes to minimize (or maximize) the primary objective function and the penalty function. For example, penalties can be added to a problem to penalize solutions that are excessively fragmented (using add_boundary_penalties). These penalties have a penalty argument that specifies the relative importance of having spatially clustered solutions. When the argument to penalty is high, then solutions which are less fragmented are valued more highly—even if they cost more—and when the argument to penalty is low, then the solutions which are more fragmented are valued less highly. After building a conservation problem, it can then be solved to obtain a solution (or portfolio of solutions if desired). The solution is returned in the same format as the planning unit data used to construct the problem. This means that if raster or shapefile / vector data was used when initializing the problem, then the solution will also be in raster or shapefile / vector data. This can be very helpful when it comes to interpreting and visualizing solutions because it means that the solution data does not first have to be merged with spatial data before they can be plotted on a map. 4.2 Usage Here we will provide an introduction to using the prioritizr R package to build and solve a conservation planning problem. Please note that we will not discuss conservation planning with multiple zones in this vignette, for more information on working with multiple management zones please see the zones vignette. First, we will load the prioritizr package. # load package library(prioritizr) # set default options for printing tabular data options(tibble.width = Inf) 4.2.1 Data Now we will load some built-in data sets that are distributed with the prioritizr R package. This package contains several different planning unit data sets. To provide a comprehensive overview of the different ways that we can initialize a conservation planning problem, we will load each of them. First, we will load the raster planning unit data (sim_pu_raster). Here, the planning units are represented as a raster (i.e. a RasterLayer object) and each pixel corresponds to the spatial extent of each panning unit. The pixel values correspond to the acquisition costs of each planning unit. # load raster planning unit data data(sim_pu_raster) # print description of the data print(sim_pu_raster) ## class : RasterLayer ## dimensions : 10, 10, 100 (nrow, ncol, ncell) ## resolution : 0.1, 0.1 (x, y) ## extent : 0, 1, 0, 1 (xmin, xmax, ymin, ymax) ## crs : NA ## source : memory ## names : layer ## values : 190.1328, 215.8638 (min, max) # plot the data plot(sim_pu_raster) Secondly, we will load one of the spatial vector planning unit data sets (sim_pu_polygons). Here, each polygon (i.e. feature using ArcGIS terminology) corresponds to a different planning unit. This data set has an attribute table that contains additional information about each polygon. Namely, the cost field (column) in the attribute table contains the acquisition cost for each planning unit. # load polygon planning unit data data(sim_pu_polygons) # print first six rows of attribute table head(sim_pu_polygons@data) ## cost locked_in locked_out ## 1 215.8638 FALSE FALSE ## 2 212.7823 FALSE FALSE ## 3 207.4962 FALSE FALSE ## 4 208.9322 FALSE TRUE ## 5 214.0419 FALSE FALSE ## 6 213.7636 FALSE FALSE # plot the planning units spplot(sim_pu_polygons, zcol = &quot;cost&quot;) Thirdly, we will load some planning unit data stored in tabular format (i.e. data.frame format). For those familiar with Marxan or dealing with very large conservation planning problems (&gt; 10 million planning units), it may be useful to work with data in this format because it does not contain any spatial information which will reduce computational burden. When using tabular data to initialize conservation planning problems, the data must follow the conventions used by Marxan. Specifically, each row in the planning unit table must correspond to a different planning unit. The table must also have an “id” column to provide a unique integer identifier for each planning unit, and it must also have a column that indicates the cost of each planning unit. For more information, please see the official Marxan documentation. # specify file path for planning unit data pu_path &lt;- system.file(&quot;extdata/input/pu.dat&quot;, package = &quot;prioritizr&quot;) # load in the tabular planning unit data # note that we use the data.table::fread function, as opposed to the read.csv # function, because it is much faster pu_dat &lt;- data.table::fread(pu_path, data.table = FALSE) # preview first six rows of the tabular planning unit data # note that it has some extra columns other than id and cost as per the # Marxan format head(pu_dat) ## id cost status xloc yloc ## 1 3 0.0 0 1116623 -4493479 ## 2 30 752727.5 3 1110623 -4496943 ## 3 56 3734907.5 0 1092623 -4500408 ## 4 58 1695902.1 0 1116623 -4500408 ## 5 84 3422025.6 0 1098623 -4503872 ## 6 85 17890758.4 0 1110623 -4503872 Finally, we will load data showing the spatial distribution of the conservation features. Our conservation features (sim_features) are represented as a stack of raster objects (i.e. a RasterStack object) where each layer corresponds to a different feature (e.g. a multi-band GeoTIFF where each band corresponds to a different feature). The pixel values in each layer correspond to the amount of suitable habitat available in a given planning unit. Note that our planning unit raster layer and our conservation feature stack have exactly the same spatial properties (i.e. resolution, extent, coordinate reference system) so their pixels line up perfectly. # load feature data data(sim_features) # plot the distribution of suitable habitat for each feature plot(sim_features, main = paste(&quot;Feature&quot;, seq_len(nlayers(sim_features))), nr = 2, box = FALSE, axes = FALSE) 4.2.2 Initialize a problem After having loaded our planning unit and feature data, we will now try initializing the some conservation planning problems. There are a lot of different ways to initialize a conservation planning problem, so here we will just showcase a few of the more commonly used methods. For an exhaustive description of all the ways you can initialize a conservation problem, see the help file for the problem function (which you can open using the code ?problem). First off, we will initialize a conservation planning problem using the raster data. # create problem p1 &lt;- problem(sim_pu_raster, sim_features) # print problem print(p1) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: none ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default # print number of planning units number_of_planning_units(p1) ## [1] 90 # print number of features number_of_features(p1) ## [1] 5 Generally, we recommend initializing problems using raster data where possible. This is because the problem function needs to calculate the amount of each feature in each planning unit, and by providing both the planning unit and feature data in raster format with the same spatial resolution, extents, and coordinate systems, this means that the problem function does not need to do any geo-processing behind the scenes. But sometimes we can’t use raster planning unit data because our planning units aren’t equal-sized grid cells. So, below is an example showing how we can initialize a conservation planning problem using planning units that are formatted as spatial vector data. Note that if we had pre-computed the amount of each feature in each planning unit and stored the data in the attribute table, we could pass in the names of the columns as an argument to the problem function. # create problem with spatial vector data # note that we have to specify which column in the attribute table contains # the cost data p2 &lt;- problem(sim_pu_polygons, sim_features, cost_column = &quot;cost&quot;) # print problem print(p2) ## Conservation Problem ## planning units: SpatialPolygonsDataFrame (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: none ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default We can also initialize a conservation planning problem using tabular planning unit data (i.e. a data.frame). Since the tabular planning unit data does not contain any spatial information, we also have to provide the feature data in tabular format (i.e. a data.frame) and data showing the amount of each feature in each planning unit in tabular format (i.e. a data.frame). The feature data must have an “id” column containing a unique integer identifier for each feature, and the planning unit by feature data must contain the following three columns: “pu” corresponding to the planning unit identifiers, “species” corresponding to the feature identifiers, and “amount” showing the amount of a given feature in a given planning unit. # set file path for feature data spec_path &lt;- system.file(&quot;extdata/input/spec.dat&quot;, package = &quot;prioritizr&quot;) # load in feature data spec_dat &lt;- data.table::fread(spec_path, data.table = FALSE) # print first six rows of the data # note that it contains extra columns head(spec_dat) ## id prop spf name ## 1 10 0.3 1 bird1 ## 2 11 0.3 1 nvis2 ## 3 12 0.3 1 nvis8 ## 4 13 0.3 1 nvis9 ## 5 14 0.3 1 nvis14 ## 6 15 0.3 1 nvis20 # set file path for planning unit vs. feature data puvspr_path &lt;- system.file(&quot;extdata/input/puvspr.dat&quot;, package = &quot;prioritizr&quot;) # load in planning unit vs feature data puvspr_dat &lt;- data.table::fread(puvspr_path, data.table = FALSE) # print first six rows of the data head(puvspr_dat) ## species pu amount ## 1 26 56 1203448.84 ## 2 26 58 451670.10 ## 3 26 84 680473.75 ## 4 26 85 97356.24 ## 5 26 86 78034.76 ## 6 26 111 4783274.17 # create problem p3 &lt;- problem(pu_dat, spec_dat, cost_column = &quot;cost&quot;, rij = puvspr_dat) # print problem print(p3) ## Conservation Problem ## planning units: data.frame (1751 units) ## cost: min: 0, max: 41569219.38232 ## features: bird1, nvis2, nvis8, ... (17 features) ## objective: none ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default For more information on initializing problems, please see the help page for the problem function (which you can open using the code ?problem). Now that we have initialized a conservation planning problem, we will show you how you can customize it to suit the exact needs of your conservation planning scenario. Although we initialized the conservation planning problems using several different methods, moving forward, we will only use raster-based planning unit data to keep things simple. 4.2.3 Add an objective The next step is to add an objective to the problem. A problem objective is used to specify the primary goal of the problem (i.e. the quantity that is to be maximized or minimized). All conservation planning problems involve minimizing or maximizing some kind of objective. For instance, we might require a solution that conserves enough habitat for each species while minimizing the overall cost of the reserve network. Alternatively, we might require a solution that maximizes the number of conserved species while ensuring that the cost of the reserve network does not exceed the budget. Please note that objectives are added in the same way regardless of the type of data used to initialize the problem. The prioritizr R package supports a variety of different objective functions. Minimum set objective: Minimize the cost of the solution whilst ensuring that all targets are met (Rodrigues et al. 2000). This objective is similar to that used in Marxan (Ball et al. 2009). For example, we can add a minimum set objective to a problem using the following code. # create a new problem that has the minimum set objective p3 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() # print the problem print(p3) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Maximum cover objective: Represent at least one instance of as many features as possible within a given budget (Church et al. 1996). # create a new problem that has the maximum coverage objective and a budget # of 5000 p4 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_max_cover_objective(5000) # print the problem print(p4) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Maximum coverage objective [budget (5000)] ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Maximum features objective: Fulfill as many targets as possible while ensuring that the cost of the solution does not exceed a budget (inspired by Cabeza &amp; Moilanen 2001). This object is similar to the maximum cover objective except that we have the option of later specifying targets for each feature. In practice, this objective is more useful than the maximum cover objective because features often require a certain amount of area for them to persist and simply capturing a single instance of habitat for each feature is generally unlikely to enhance their long-term persistence. # create a new problem that has the maximum features objective and a budget # of 5000 p5 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_max_features_objective(budget = 5000) # print the problem print(p5) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Maximum representation objective [budget (5000)] ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Minimum shortfall objective: Minimize the shortfall for as many targets as possible while ensuring that the cost of the solution does not exceed a budget. In practice, this objective useful when there is a large amount of left-over budget when using the maximum feature representation objective and the remaining funds need to be allocated to places that will enhance the representation of features with unmet targets. # create a new problem that has the minimum shortfall objective and a budget # of 5000 p6 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_shortfall_objective(budget = 5000) # print the problem print(p6) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum shortfall objective [budget (5000)] ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Maximum phylogenetic diversity objective: Maximize the phylogenetic diversity of the features represented in the solution subject to a budget (inspired by Faith 1992; Rodrigues &amp; Gaston 2002). This objective is similar to the maximum features objective except that emphasis is placed on protecting features which are associated with a diverse range of evolutionary histories. The prioritizr R package contains a simulated phylogeny that can be used with the simulated feature data (sim_phylogny). # load simulated phylogeny data data(sim_phylogeny) # create a new problem that has the maximum phylogenetic diversity # objective and a budget of 5000 p7 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_max_phylo_div_objective(budget = 5000, tree = sim_phylogeny) # print the problem print(p7) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Phylogenetic diversity objective [budget (5000)] ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Maximum phylogenetic endemism objective: Maximize the phylogenetic endemism of the features represented in the solution subject to a budget (inspired by Faith 1992; Rodrigues &amp; Gaston 2002; Rosauer et al. 2009). This objective is similar to the maximum phylogenetic diversity except that emphasis is placed conserving features that are associated with geographically restricted periods of evolutionary history rather than a diverse range of evolutionary histories. # load simulated phylogeny data data(sim_phylogeny) # create a new problem that has the maximum phylogenetic diversity # objective and a budget of 5000 p8 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_max_phylo_end_objective(budget = 5000, tree = sim_phylogeny) # print the problem print(p8) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Phylogenetic endemism objective [budget (5000)] ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Maximum utility objective: Secure as much of the features as possible without exceeding a budget. This objective is functionally equivalent to selecting the planning units with the greatest amounts of each feature (e.g. species richness). Generally, we don’t encourage the use of this objective because it will only rarely identify complementary solutions—solutions which adequately conserve a range of different features—except perhaps to explore trade-offs or provide a baseline solution with which to compare other solutions. # create a new problem that has the maximum utility objective and a budget # of 5000 p9 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_max_utility_objective(budget = 5000) # print the problem print(p9) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Maximum utility objective [budget (5000)] ## targets: none ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default 4.2.4 Add targets Most conservation planning problems require targets. Targets are used to specify the minimum amount or proportion of a feature’s distribution that needs to be protected in the solution. For example, we may want to develop a reserve network that will secure 20% of the distribution for each feature for minimal cost. There are four ways for specifying targets in the prioritizr R package: Absolute targets: Targets are expressed as the total amount of each feature in the study area that need to be secured. For example, if we had binary feature data that showed the absence or presence of suitable habitat across the study area, we could set an absolute target as 5 to mean that we require 5 planning units with suitable habitat in the solution. # create a problem with targets which specify that the solution must conserve # a need a sum total of 3 units of suitable habitat for each feature p10 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_absolute_targets(3) # print problem print(p10) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Absolute targets [targets (min: 3, max: 3)] ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Relative targets: Targets are set as a proportion (between 0 and 1) of the total amount of each feature in the study area. For example, if we had binary feature data and the feature occupied a total of 20 planning units in the study area, we could set a relative target of 50 % to specify that the solution must secure 10 planning units for the feature. We could alternatively specify an absolute target of 10 to achieve the same result, but sometimes proportions are easier to work with. # create a problem with the minimum set objective and relative targets of 10 % # for each feature p11 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) # print problem print(p11) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default # create a problem with targets which specify that we need 10 % of the habitat # for the first feature, 15 % for the second feature, 20 % for the third feature # 25 % for the fourth feature and 30 % of the habitat for the fifth feature targets &lt;- c(0.1, 0.15, 0.2, 0.25, 0.3) p12 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(targets) # print problem print(p12) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.3)] ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Log-linear targets: Targets are expressed using scaling factors and log-linear interpolation. This method for specifying targets is commonly used for global prioritization analyses (Rodrigues et al. 2004). # create problem with added log-linear targets p13 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_loglinear_targets(10, 0.9, 100, 0.2) # print problem print(p13) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Absolute targets [targets (min: 17.290505409161, max: 21.5906174426385)] ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Manual targets: Targets are manually specified. This is only really recommended for advanced users or problems that involve multiple management zones. See the zones vignette for more information on these targets. As with the functions for specifying the objective of a problem, if we try adding multiple targets to a problem, only the most recently added set of targets are used. 4.2.5 Add constraints A constraint can be added to a conservation planning problem to ensure that all solutions exhibit a specific property. For example, they can be used to make sure that all solutions select a specific planning unit or that all selected planning units in the solution follow a certain configuration. The following constraints can be added to conservation planning problems in the prioritizr R package. Locked in constraints: Add constraints to ensure that certain planning units are prioritized in the solution. For example, it may be desirable to lock in planning units that are inside existing protected areas so that the solution fills in the gaps in the existing reserve network. # create problem with constraints which specify that the first planning unit # must be selected in the solution p14 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_locked_in_constraints(1) # print problem print(p14) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;Locked in planning units [1 locked units]&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Locked out constraints: Add constraints to ensure that certain planning units are not prioritized in the solution. For example, it may be useful to lock out planning units that have been degraded and are not suitable for conserving species. # create problem with constraints which specify that the second planning unit # must not be selected in the solution p15 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_locked_out_constraints(2) # print problem print(p15) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;Locked out planning units [1 locked units]&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Neighbor constraints: Add constraints to a conservation problem to ensure that all selected planning units have at least a certain number of neighbors. # create problem with constraints which specify that all selected planning units # in the solution must have at least 1 neighbor p16 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_neighbor_constraints(1) # print problem print(p16) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;Neighbor constraint [number of neighbors (1), zones]&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Contiguity constraints: Add constraints to a conservation problem to ensure that all selected planning units are spatially connected to each other and form spatially contiguous unit. # create problem with constraints which specify that all selected planning units # in the solution must form a single contiguous unit p17 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_contiguity_constraints() # print problem print(p17) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;Contiguity constraints [apply constraints? (1), zones]&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Feature contiguity constraints: Add constraints to ensure that each feature is represented in a contiguous unit of dispersible habitat. These constraints are a more advanced version of those implemented in the add_contiguity_constraints function, because they ensure that each feature is represented in a contiguous unit and not that the entire solution should form a contiguous unit. # create problem with constraints which specify that the planning units used # to conserve each feature must form a contiguous unit p18 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_feature_contiguity_constraints() # print problem print(p18) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;Feature contiguity constraints [apply constraints? (1), layer.1 zones, layer.2 zones, layer.3 zones, layer.4 zones, layer.5 zones]&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Mandatory allocation constraints: Add constraints to ensure that every planning unit is allocated to a management zone in the solution. Please note that this function can only be used with problems that contain multiple zones. For more information on problems with multiple zones and an example using this function, see the Management Zones vignette. In particular, The add_locked_in_constraints and add_locked_out_constraints functions are incredibly useful for real-world conservation planning exercises, so it’s worth pointing out that there are several ways we can specify which planning units should be locked in or out of the solutions. If we use raster planning unit data, we can also use raster data to specify which planning units should be locked in our locked out. # load data to lock in or lock out planning units data(sim_locked_in_raster) data(sim_locked_out_raster) # plot the locked data plot(stack(sim_locked_in_raster, sim_locked_out_raster), main = c(&quot;Locked In&quot;, &quot;Locked Out&quot;)) # create a problem using raster planning unit data and use the locked raster # data to lock in some planning units and lock out some other planning units p19 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_locked_in_constraints(sim_locked_in_raster) %&gt;% add_locked_out_constraints(sim_locked_out_raster) # print problem print(p19) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;Locked in planning units [10 locked units] ## Locked out planning units [10 locked units]&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default If our planning unit data are in a spatial vector format (similar to the sim_pu_polygons data) or a tabular format (similar to pu_dat), we can use the field names in the data to refer to which planning units should be locked in and / or out. For example, the sim_pu_polygons object has TRUE / FALSE values in the “locked_in” field which indicate which planning units should be selected in the solution. We could use the data in this field to specify that those planning units with TRUE values should be locked in using the following methods. # preview first six rows of the attribute table for sim_pu_polygons head(sim_pu_polygons@data) ## cost locked_in locked_out ## 1 215.8638 FALSE FALSE ## 2 212.7823 FALSE FALSE ## 3 207.4962 FALSE FALSE ## 4 208.9322 FALSE TRUE ## 5 214.0419 FALSE FALSE ## 6 213.7636 FALSE FALSE # specify locked in data using the field name p20 &lt;- problem(sim_pu_polygons, sim_features, cost_column = &quot;cost&quot;) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_locked_in_constraints(&quot;locked_in&quot;) # print problem print(p20) ## Conservation Problem ## planning units: SpatialPolygonsDataFrame (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;Locked in planning units [10 locked units]&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default # specify locked in data using the values in the field p21 &lt;- problem(sim_pu_polygons, sim_features, cost_column = &quot;cost&quot;) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_locked_in_constraints(which(sim_pu_polygons$locked_in)) # print problem print(p21) ## Conservation Problem ## planning units: SpatialPolygonsDataFrame (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;Locked in planning units [10 locked units]&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default 4.2.6 Add penalties We can also add penalties to a problem to favor or penalize solutions according to a secondary objective. Unlike the constraint functions, these functions will add extra information to the objective function of the optimization function to penalize solutions that do not exhibit specific characteristics. For example, penalties can be added to a problem to avoid highly fragmented solutions at the expense of accepting slightly more expensive solutions. All penalty functions have a penalty argument that controls the relative importance of the secondary penalty function compared to the primary objective function. It is worth noting that incredibly low or incredibly high penalty values—relative to the main objective function—can cause problems to take a very long time to solve, so when trying out a range of different penalty values it can be helpful to limit the solver to run for a set period of time. The prioritizr R package currently offers only two methods for adding penalties to a conservation planning problem. Boundary penalties: Add penalties to penalize solutions that are excessively fragmented. These penalties are similar to those used in Marxan (Ball et al. 2009; Beyer et al. 2016). # create problem with penalties that penalize fragmented solutions with a # penalty factor of 0.01 p22 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_boundary_penalties(penalty = 0.01) # print problem print(p22) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;Boundary penalties [edge factor (min: 0.5, max: 0.5), penalty (0.01), zones]&gt; ## portfolio: default ## solver: default Connectivity penalties: Add penalties to favor solutions that select combinations of planning units with high connectivity between them. These penalties are similar to those used in Marxan with Zones (Watts et al. 2009; Beyer et al. 2016). This function supports both symmetric and asymmetric connectivities among planning units. # create problem with penalties that favor combinations of planning units with # high connectivity, here we will use only the first four layers in # sim_features for the features and we will use the fifth layer in sim_features # to represent the connectivity data, where the connectivity_matrix function # will create a matrix showing the average strength of connectivity between # adjacent planning units using the data in the fifth layer of sim_features p23 &lt;- problem(sim_pu_raster, sim_features[[1:4]]) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_boundary_penalties(penalty = 5, data = connectivity_matrix(sim_pu_raster, sim_features[[5]])) # print problem print(p23) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, layer.4 (4 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;Boundary penalties [edge factor (min: 0.5, max: 0.5), penalty (5), zones]&gt; ## portfolio: default ## solver: default Linear penalties: Add penalties to penalize solutions that select planning units according to a certain variable (e.g. anthropogenic pressure). # create data for penalizing planning units pen_raster &lt;- simulate_cost(sim_pu_raster) # create problem with penalties that penalize solutions that select # planning units with high values in the pen_raster object, # here we will use a penalty value of 5 to indicate the trade-off (scaling) # between the penalty values (in the sim_pu_raster) and the main objective # (i.e. the cost of the solution) p24 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_linear_penalties(penalty = 5, data = pen_raster) # print problem print(p24) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: default ## constraints: &lt;none&gt; ## penalties: &lt;Linear penalties [penalty (5)]&gt; ## portfolio: default ## solver: default 4.2.7 Add the decision types Conservation planning problems involve making decisions on how planning units will be managed. These decisions are then associated with management actions (e.g. turning a planning unit into a protected area). The type of decision describes how the action is applied to planning units. For instance, the default decision-type is a binary decision type, meaning that we are either selecting or not selecting planning units for management. The prioritizr R package currently offers the following types of decisions for customizing problems. Binary decisions: Add a binary decision to a conservation planning problem. This is the classic decision of either prioritizing or not prioritizing a planning unit. Typically, this decision has the assumed action of buying the planning unit to include in a protected area network. If no decision is added to a problem object, then this decision class will be used by default. # add binary decisions to a problem p25 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_binary_decisions() # print problem print(p25) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: Binary decision ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Proportion decisions: Add a proportion decision to a problem. This is a relaxed decision where a part of a planning unit can be prioritized, as opposed to the default of the entire planning unit. Typically, this decision has the assumed action of buying a fraction of a planning unit to include in a protected area network. Generally, problems can be solved much faster with proportion-type decisions than binary-type decisions, so they can be very useful when commercial solvers are not available. # add proportion decisions to a problem p26 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_proportion_decisions() # print problem print(p26) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: Proportion decision ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default Semi-continuous decisions: Add a semi-continuous decision to a problem. This decision is similar to proportion decisions except that it has an upper bound parameter. By default, the decision can range from prioritizing none (0%) to all (100%) of a planning unit. However, a upper bound can be specified to ensure that at most only a fraction (e.g. 80%) of a planning unit can be purchased. This type of decision may be useful when it is not practical to conserve the entire area indicated by a planning unit. # add semi-continuous decisions to a problem, where we can only manage at most # 50 % of the area encompassed by a planning unit p27 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_semicontinuous_decisions(0.5) # print problem print(p27) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: Semicontinuous decision [upper limit (0.5)] ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: default 4.2.8 Add a solver Next, after specifying the mathematical formulation that underpins your conservation planning problem, you can specify how the problem should be solved. If you do not specify this information, the prioritizr R package will automatically use the best solver currently installed on your system with some reasonable defaults. We strongly recommend installing the Gurobi software suite and the gurobi R package to solve problems, and for more information on this topic please refer to the Gurobi Installation Guide. Currently, the prioritizr R package only supports three different solvers. Gurobi solver: Gurobi is a state of the art commercial optimization software. It is by far the fastest of the solvers that can be used to solve conservation problems. However, it is not freely available. That said, special licenses are available to academics at no cost. # create a problem and specify that Gurobi should be used to solve the problem # and specify an optimality gap of zero to obtain the optimal solution p28 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_binary_decisions() %&gt;% add_gurobi_solver(gap = 0) # print problem print(p28) ## Conservation Problem ## planning units: RasterLayer (90 units) ## cost: min: 190.13276, max: 215.86384 ## features: layer.1, layer.2, layer.3, ... (5 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.1, max: 0.1)] ## decisions: Binary decision ## constraints: &lt;none&gt; ## penalties: &lt;none&gt; ## portfolio: default ## solver: Gurobi [first_feasible (0), gap (0), numeric_focus (0), presolve (2), threads (1), time_limit (2147483647), verbose (1)] IBM CPLEX solver: IBM CPLEX is a commercial optimization software. It is faster than the open source solvers available for generating prioritizations (see below), however, it is not freely available. Similar to the Gurobi software, special licenses are available to academics at no cost. # create a problem and specify that IBM CPLEX should be used to solve the # problem and specify an optimality gap of zero to obtain the optimal solution # p29 &lt;- problem(sim_pu_raster, sim_features) %&gt;% # add_min_set_objective() %&gt;% # add_relative_targets(0.1) %&gt;% # add_binary_decisions() %&gt;% # add_cplex_solver(gap = 0) # # # print problem # print(p29) Rsymphony solver: SYMPHONY is an open-source integer programming solver that is part of the Computational Infrastructure for Operations Research (COIN-OR) project, an initiative to promote development of open-source tools for operations research. The Rsymphony R package provides an interface to COIN-OR and is available on The Comprehensive R Archive Network (CRAN). # create a problem and specify that Rsymphony should be used to solve the # problem and specify an optimality gap of zero to obtain the optimal solution # p30 &lt;- problem(sim_pu_raster, sim_features) %&gt;% # add_min_set_objective() %&gt;% # add_relative_targets(0.1) %&gt;% # add_binary_decisions() %&gt;% # add_rsymphony_solver(gap = 0) # # # print problem # print(p30) lpsymphony solver: The lpsymphony R package provides a different interface to the COIN-OR software suite. This package may be easier to install on Windows and Mac OSX operating systems than the Rsymphony R package. Unlike the Rsymphony R package, the lpsymphony R package is distributed through Bioconductor. # create a problem and specify that lpsymphony should be used to solve the # problem and specify an optimality gap of zero to obtain the optimal solution # p31 &lt;- problem(sim_pu_raster, sim_features) %&gt;% # add_min_set_objective() %&gt;% # add_relative_targets(0.1) %&gt;% # add_binary_decisions() %&gt;% # add_lpsymphony_solver(gap = 0) # # # print problem # print(p31) 4.2.9 Add a portfolio Many conservation planning exercises require a portfolio of solutions. For example, real-world exercises can involve presenting decision makers with a range of near-optimal decisions. Additionally, the number of times that different planning units are selected in different solutions can provide insight into their relative importance. The following methods are available for generating a portfolio of solutions. Extra portfolio: Generate a portfolio of solutions by storing feasible solutions found during the optimization process. Note that this method requires that the Gurobi optimization software is used to generate solutions. # create a problem and specify that a portfolio should be created using # extra solutions found while solving the problem # p32 &lt;- problem(sim_pu_raster, sim_features) %&gt;% # add_min_set_objective() %&gt;% # add_relative_targets(0.1) %&gt;% # add_binary_decisions() %&gt;% # add_extra_portfolio() # # # print problem # print(p32) Top portfolio: Generate a portfolio of solutions by finding a pre-specified number of solutions that are closest to optimality (i.e the top solutions). Note that this method requires that the Gurobi optimization software is used to generate solutions. # create a problem and specify that a portfolio should be created using # the top five solutions # p33 &lt;- problem(sim_pu_raster, sim_features) %&gt;% # add_min_set_objective() %&gt;% # add_relative_targets(0.1) %&gt;% # add_binary_decisions() %&gt;% # add_top_portfolio(number_solutions = 5) # # # print problem # print(p33) Gap portfolio: Generate a portfolio of solutions by finding a certain number of solutions that are all within a pre-specified optimality gap. This method is especially useful for generating multiple solutions that can used be to calculate selection frequencies (similar to Marxan). Note that this method requires that the Gurobi optimization software is used to generate solutions. # create a problem and specify that a portfolio should be created by # finding five solutions within 10% of optimality # p34 &lt;- problem(sim_pu_raster, sim_features) %&gt;% # add_min_set_objective() %&gt;% # add_relative_targets(0.1) %&gt;% # add_binary_decisions() %&gt;% # add_gap_portfolio(number_solutions = 5, pool_gap = 0.2) # # # print problem # print(p34) Cuts portfolio: Generate a portfolio of distinct solutions within a pre-specified optimality gap. This method is only recommended if the Gurobi optimization solver is not available. # create a problem and specify that a portfolio containing 10 solutions # should be created using using Bender&#39;s cuts # p35 &lt;- problem(sim_pu_raster, sim_features) %&gt;% # add_min_set_objective() %&gt;% # add_relative_targets(0.1) %&gt;% # add_binary_decisions() %&gt;% # add_cuts_portfolio(number_solutions = 10) # # # print problem # print(p35) Shuffle portfolio: Generate a portfolio of solutions by randomly reordering the data prior to attempting to solve the problem. If the Gurobi optimization solver is not available, this method is the fastest method for generating a set number of solutions within a specified distance from optimality. # create a problem and specify a portfolio should be created that contains # 10 solutions and that any duplicate solutions should not be removed # p36 &lt;- problem(sim_pu_raster, sim_features) %&gt;% # add_min_set_objective() %&gt;% # add_relative_targets(0.1) %&gt;% # add_binary_decisions() %&gt;% # add_shuffle_portfolio(number_solutions = 10, remove_duplicates = FALSE) # # # print problem # print(p36) 4.2.10 Solve the problem Finally, after formulating our conservation planning problem and specifying how the problem should be solved, we can use the solve function to obtain a solution. Note that the solver will typically print out some information describing the size of the problem and report its progress when searching for a suitable solution. # formulate the problem p37 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_boundary_penalties(penalty = 500, edge_factor = 0.5) %&gt;% add_binary_decisions() # solve the problem (using the default solver) s37 &lt;- solve(p37) ## Gurobi Optimizer version 9.1.1 build v9.1.1rc0 (mac64) ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ## Optimize a model with 293 rows, 234 columns and 1026 nonzeros ## Model fingerprint: 0xbd38144b ## Variable types: 0 continuous, 234 integer (234 binary) ## Coefficient statistics: ## Matrix range [2e-01, 1e+00] ## Objective range [1e+02, 4e+02] ## Bounds range [1e+00, 1e+00] ## RHS range [3e+00, 8e+00] ## Found heuristic solution: objective 20287.196992 ## Found heuristic solution: objective 3087.9617505 ## Presolve time: 0.00s ## Presolved: 293 rows, 234 columns, 1026 nonzeros ## Variable types: 0 continuous, 234 integer (234 binary) ## Presolved: 293 rows, 234 columns, 1026 nonzeros ## ## ## Root relaxation: objective 2.265862e+03, 218 iterations, 0.00 seconds ## ## Nodes | Current Node | Objective Bounds | Work ## Expl Unexpl | Obj Depth IntInf | Incumbent BestBd Gap | It/Node Time ## ## 0 0 2265.86242 0 234 3087.96175 2265.86242 26.6% - 0s ## H 0 0 2920.9854189 2265.86242 22.4% - 0s ## 0 0 2327.26806 0 232 2920.98542 2327.26806 20.3% - 0s ## 0 0 2368.37316 0 226 2920.98542 2368.37316 18.9% - 0s ## 0 0 2376.91951 0 223 2920.98542 2376.91951 18.6% - 0s ## 0 0 2376.91951 0 223 2920.98542 2376.91951 18.6% - 0s ## H 0 0 2910.0202492 2376.91951 18.3% - 0s ## H 0 0 2676.6543486 2376.91951 11.2% - 0s ## 0 2 2377.44918 0 223 2676.65435 2377.44918 11.2% - 0s ## H 27 27 2676.6537993 2377.44918 11.2% 16.9 0s ## H 56 40 2676.6531808 2388.87827 10.8% 16.2 0s ## ## Cutting planes: ## Gomory: 3 ## ## Explored 57 nodes (1397 simplex iterations) in 0.15 seconds ## Thread count was 1 (of 8 available processors) ## ## Solution count 5: 2676.65 2910.02 2920.99 ... 20287.2 ## ## Optimal solution found (tolerance 1.00e-01) ## Best objective 2.676653180861e+03, best bound 2.413625263266e+03, gap 9.8267% # plot solution plot(s37, col = c(&quot;grey90&quot;, &quot;darkgreen&quot;), main = &quot;Solution&quot;, xlim = c(-0.1, 1.1), ylim = c(-0.1, 1.1)) We can plot this solution because the planning unit input data are spatially referenced in a raster format. The output format will always match the planning unit data used to initialize the problem. For example, the solution to a problem with planning units in a spatial vector (shapefile) format would also be in a spatial vector format. Similarly, if the planning units were in a tabular format (i.e. data.frame), the solution would also be returned in a tabular format. We can also extract attributes from the solution that describe the quality of the solution and the optimization process. # extract the objective (numerical value being minimized or maximized) print(attr(p37, &quot;objective&quot;)) ## NULL # extract time spent solving solution print(attr(p37, &quot;runtime&quot;)) ## NULL # extract state message from the solver that describes why this specific # solution was returned print(attr(p37, &quot;status&quot;)) ## NULL 4.2.11 Marxan problems Although users are encouraged to build and tailor conservation planning problems to suit their own needs using the problem function, sometimes it just simply easier to use a more familiar formulation. The marxan_problem function is provided as a convenient wrapper for building and solving Marxan-style conservation problems. If users already have their conservation planning data formatted for use with Marxan, this function can also read Marxan data files and solve the Marxan-style problems using exact algorithm solvers. Please note that problems built using the marxan_problem function are still solved the same way as a problem initialized using the problem function, and therefore still require the installation of one of the solver packages. Here is a short example showing how the marxan_problem function can be used to read Marxan input files and the solve function can be used to solve the problem. # set file path for Marxan input file minput &lt;- system.file(&quot;extdata/input.dat&quot;, package = &quot;prioritizr&quot;) # read Marxan input file mp &lt;- marxan_problem(minput) # print problem print(mp) ## Conservation Problem ## planning units: data.frame (1751 units) ## cost: min: 0, max: 41569219.38232 ## features: bird1, nvis2, nvis8, ... (17 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.3, max: 0.3)] ## decisions: default ## constraints: &lt;Locked out planning units [1 locked units] ## Locked in planning units [317 locked units]&gt; ## penalties: &lt;Boundary penalties [edge factor (min: 1, max: 1), penalty (1), zones]&gt; ## portfolio: default ## solver: default # solve the problem ms &lt;- solve(mp) # since the Marxan data was in a tabular format, the solution is also returned # in a tabular format, so we will print the first six rows of the table # containing the solution head(ms) Alternatively, rather then using a Marxan input file to construct the problem, we can manually read in the Marxan data files and input these to the marxan_problem function. # load data pu &lt;- system.file(&quot;extdata/input/pu.dat&quot;, package = &quot;prioritizr&quot;) %&gt;% read.table(sep = &quot;,&quot;, header = TRUE) features &lt;- system.file(&quot;extdata/input/spec.dat&quot;, package = &quot;prioritizr&quot;) %&gt;% read.table(sep = &quot;,&quot;, header = TRUE) bound &lt;- system.file(&quot;extdata/input/bound.dat&quot;, package = &quot;prioritizr&quot;) %&gt;% read.table(sep = &quot;\\t&quot;, header = TRUE) rij &lt;- system.file(&quot;extdata/input/puvspr.dat&quot;, package = &quot;prioritizr&quot;) %&gt;% read.table(sep = &quot;,&quot;, header = TRUE) # build Marxan problem using data.frame objects mp2 &lt;- marxan_problem(x = pu, spec = features, puvspr = rij, bound = bound, blm = 0) # print problem print(mp2) ## Conservation Problem ## planning units: data.frame (1751 units) ## cost: min: 0, max: 41569219.38232 ## features: bird1, nvis2, nvis8, ... (17 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.3, max: 0.3)] ## decisions: default ## constraints: &lt;Locked out planning units [1 locked units] ## Locked in planning units [317 locked units]&gt; ## penalties: &lt;Boundary penalties [edge factor (min: 1, max: 1), penalty (0), zones]&gt; ## portfolio: default ## solver: default 4.2.12 Evaluate the performance of a solution After obtaining a solution to a conservation planning problem, it can be useful to calculate various summary statistics to understand its performance. The following functions are available to summarize a solution: Calculate the number of planning units selected within a solution. # calculate statistic eval_n_summary(p37, s37) ## # A tibble: 1 x 2 ## summary cost ## &lt;chr&gt; &lt;dbl&gt; ## 1 overall 10 Calculate the total cost of a solution. # calculate statistic eval_cost_summary(p37, s37) ## # A tibble: 1 x 2 ## summary cost ## &lt;chr&gt; &lt;dbl&gt; ## 1 overall 2002. Calculate how well features are represented by a solution. This function can be used for problems that are built using targets and those that are not built using targets. # calculate statistics eval_feature_representation_summary(p37, s37) ## # A tibble: 5 x 5 ## summary feature total_amount absolute_held relative_held ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 overall layer.1 83.3 8.96 0.108 ## 2 overall layer.2 31.2 3.19 0.102 ## 3 overall layer.3 72.0 7.56 0.105 ## 4 overall layer.4 42.7 4.32 0.101 ## 5 overall layer.5 56.7 5.93 0.105 Calculate how well feature representation targets are met by a solution. This function can only be used with problems contain targets. # calculate statistics eval_target_coverage_summary(p37, s37) ## # A tibble: 5 x 9 ## feature met total_amount absolute_target absolute_held absolute_shortfall relative_target relative_held ## &lt;chr&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 layer.1 TRUE 83.3 8.33 8.96 0 0.1 0.108 ## 2 layer.2 TRUE 31.2 3.12 3.19 0 0.1 0.102 ## 3 layer.3 TRUE 72.0 7.20 7.56 0 0.1 0.105 ## 4 layer.4 TRUE 42.7 4.27 4.32 0 0.1 0.101 ## 5 layer.5 TRUE 56.7 5.67 5.93 0 0.1 0.105 ## relative_shortfall ## &lt;dbl&gt; ## 1 0 ## 2 0 ## 3 0 ## 4 0 ## 5 0 Calculate the exposed boundary length (perimeter) associated with a solution. # calculate statistic eval_boundary_summary(p37, s37) ## # A tibble: 1 x 2 ## summary boundary ## &lt;chr&gt; &lt;dbl&gt; ## 1 overall 1.35 Calculate the connectivity held within a solution. # calculate statistic # here we use the raster data for the first feature as an example # to parametrize pair-wise connectivity between different planning units eval_connectivity_summary( p37, s37, data = connectivity_matrix(sim_pu_raster, sim_features[[1]])) ## # A tibble: 1 x 2 ## summary connectivity ## &lt;chr&gt; &lt;dbl&gt; ## 1 overall 1.80 4.2.13 Importance (irreplaceability) Conservation plans can take a long time to implement. Since funding availability and habitat quality can decline over time, it is critical that the most important places in a prioritization are scheduled for protection as early as possible. For instance, some planning units in a solution might contain many rare species which do not occur in any other planning units. Alternatively, some planning units might offer an especially high return on investment that reduces costs considerably. As a consequence, conservation planners often need information on which planning units selected in a prioritization are most important to the overall success of the prioritization. To achieve this, conservation planners can use importance (irreplaceability) scores for each planning unit selected in a solution. The prioritizr R package offers multiple methods for assessing importance. These includes scores calculated based on replacement costs [eval_replacement_importance(); Cabeza &amp; Moilanen (2006)], Ferrier et al. (2000) (eval_ferrier_importance()), and rarity weighted richness scores [eval_rare_richness_importance(); Williams et al. (1996)]. The replacement cost scores quantify the change in the objective function (e.g. additional costs required to meet feature targets) of the optimal solution if a given planning unit in a solution cannot be acquired. They can (i) account for the cost of different planning units, (ii) account for multiple management zones, (iii) apply to any objective function, and (iv) identify truly irreplaceable planning units (denoted with infinite values). The Ferrier scores quantify the importance of planning units for meeting feature targets. They can only be applied to conservation problems with a minimum set objective and a single zone (i.e. the classic Marxan-type problem). Furthermore—unlike the replacement cost scores—the Ferrier scores provide a score for each feature within each planning unit, providing insight into why certain planning units are more important than other planning units. The rarity weighted richness scores are simply a measure of biological diversity. They do not account for planning costs, multiple management zones, objective functions, or feature targets (or weightings). They merely describe the spatial patterns of biodiversity, and do not account for many of the factors needed to quantify the importance of a planning unit for achieving conservation goals. We recommend using replacement cost scores for small and moderate sized problems (e.g. less than 30,000 planning units) when it is feasible to do so. It can take a very long time to compute replacement cost scores, and so it is simply not feasible to compute these scores for particularly large problems. For moderate and large sized problems (e.g. more than 30,000 planning units), we recommend using the rarity weighted richness scores. Beware, it has been known for decades that such static measures of biodiversity lead to poor conservation plans (Kirkpatrick 1983). Although the Ferrier method is also provided, we do not recommend using this method until it has been verified by a statistical expert. Below we will generate a solution, and then calculate importance scores for the planning units selected in the solution using the three different methods. # formulate the problem p38 &lt;- problem(sim_pu_raster, sim_features) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.1) %&gt;% add_binary_decisions() # solve the problem s38 &lt;- solve(p38) ## Gurobi Optimizer version 9.1.1 build v9.1.1rc0 (mac64) ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ## Optimize a model with 5 rows, 90 columns and 450 nonzeros ## Model fingerprint: 0x6442bf6e ## Variable types: 0 continuous, 90 integer (90 binary) ## Coefficient statistics: ## Matrix range [2e-01, 9e-01] ## Objective range [2e+02, 2e+02] ## Bounds range [1e+00, 1e+00] ## RHS range [3e+00, 8e+00] ## Found heuristic solution: objective 2337.9617505 ## Presolve time: 0.00s ## Presolved: 5 rows, 90 columns, 450 nonzeros ## Variable types: 0 continuous, 90 integer (90 binary) ## Presolved: 5 rows, 90 columns, 450 nonzeros ## ## ## Root relaxation: objective 1.931582e+03, 12 iterations, 0.00 seconds ## ## Nodes | Current Node | Objective Bounds | Work ## Expl Unexpl | Obj Depth IntInf | Incumbent BestBd Gap | It/Node Time ## ## 0 0 1931.58191 0 4 2337.96175 1931.58191 17.4% - 0s ## H 0 0 1987.3985265 1931.58191 2.81% - 0s ## ## Explored 1 nodes (12 simplex iterations) in 0.00 seconds ## Thread count was 1 (of 8 available processors) ## ## Solution count 2: 1987.4 2337.96 ## ## Optimal solution found (tolerance 1.00e-01) ## Best objective 1.987398526526e+03, best bound 1.931581908865e+03, gap 2.8085% # plot solution plot(s38, col = c(&quot;grey90&quot;, &quot;darkgreen&quot;), main = &quot;Solution&quot;, xlim = c(-0.1, 1.1), ylim = c(-0.1, 1.1)) # calculate replacement cost scores and make the solver quiet rc38 &lt;- p38 %&gt;% add_default_solver(gap = 0, verbose = FALSE) %&gt;% eval_replacement_importance(s38) # plot replacement cost scores plot(rc38, main = &quot;replacement cost&quot;) # calculate Ferrier scores and extract total score fs38 &lt;- eval_ferrier_importance(p38, s38)[[&quot;total&quot;]] # plot Ferrier scores plot(fs38, main = &quot;Ferrier scores&quot;) # calculate rarity weighted richness scores rwr38 &lt;- eval_rare_richness_importance(p38, s38) # plot replacement cost scores plot(rwr38, main = &quot;rarity weighted richness&quot;) Although rarity weighted richness scores can approximate scores derived from the other two methods in certain conservation planning exercises, we can see that the rarity weighted richness scores provide completely different results in this case. 4.3 Conclusion Hopefully, this vignette has provided an informative introduction to the prioritizr R package. For more worked examples using the prioritizr R package, check out the Tasmania and Salt Spring Island vignettes. Perhaps, one of the best ways to learn a new piece of software is to just try it out. Test it, try breaking it, make mistakes, and learn from them. We would recommend trying to build conservation planning problems that resemble those you face in your own work—but using the built-in example data sets. This way you can quickly verify that the problems you build actually mean what you think they mean. For instance, you can try playing around with the targets and see what effect they have on the solutions, or try playing around with penalties and see what effect they have on the solutions. Finally, if you have any questions about using the prioritizr R package or suggestions for improving the prioritizr R package (perhaps addressing some spelling mistakes found whilst reading this vignette?), please file an issue on the package’s online coding repository (https://github.com/prioritizr/prioritizr/issues). "],["tasmania-tutorial.html", "Chapter 5 Tasmania Tutorial 5.1 Exploring the data 5.2 Marxan problem formulation 5.3 General problem formulation 5.4 Selection frequencies", " Chapter 5 Tasmania Tutorial The aim of this tutorial is to provide a worked example of how vector-based data can be used to develop conservation prioritizations using the prioritizr R package. It is also written for conservation planners that have used the Marxan decision support tool (Ball et al. 2009) and are interested in applying the prioritizr R package to their own work. The dataset used in this tutorial was obtained from the Introduction to Marxan course. This data was originally a subset of a larger spatial prioritization project performed under contract to Australia’s Department of Environment and Water Resources (Klein et al. 2007). Please note that this tutorial uses data from the prioritizrdata R, so ensure that it is installed before trying out the code yourself. 5.1 Exploring the data This dataset contains two items. First, a spatial planning unit layer that has an attribute table which contains three columns: integer unique identifiers (“id”), unimproved land values (“cost”), and their existing level of protection (“status”). Units with 50 % or more of their area contained in protected areas are associated with a status of 2, otherwise they are associated with a value of 0. If you are familiar with the Marxan decision support tool, then you will notice that these columns are formatted in a similar manner to the input data for Marxan. For Marxan input data, planning units must be described in a table containing one row for each planning unit with a unique identifier and the corresponding cost. The second item in this dataset is the raster-based feature data. Specifically, the feature data is expressed as a stack of rasters (termed a RasterStack object). Here each layer in the stack represents the distribution of a different vegetation class in Tasmania, Australia. There are 62 vegetation classes in total. For a given layer, pixel values indicate the presence (value of 1) or absence (value of 0) of the vegetation class in an area. First, load the required packages and the data. # load packages library(prioritizrdata) library(prioritizr) # load planning unit data data(tas_pu) # load conservation feature data data(tas_features) Now, let’s have a look at the planning unit data. # print planning unit data print(tas_pu) ## class : SpatialPolygonsDataFrame ## features : 1130 ## extent : 298809.6, 613818.8, 5167775, 5502544 (xmin, xmax, ymin, ymax) ## crs : +proj=utm +zone=55 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 ## variables : 5 ## names : id, cost, status, locked_in, locked_out ## min values : 1, 0.192488262910798, 0, 0, 0 ## max values : 1130, 61.9272727272727, 2, 1, 0 # plot map of planning unit costs plot(st_as_sf(tas_pu[, &quot;cost&quot;]), main = &quot;Planning unit costs&quot;) Next, let examine the feature data. Here we will only plot the first four features as an example. The pixel values denote the presence or absence of each feature within the extent of the study area. # print planning unit data print(tas_features) ## class : RasterStack ## dimensions : 398, 359, 142882, 62 (nrow, ncol, ncell, nlayers) ## resolution : 1000, 1000 (x, y) ## extent : 288801.7, 647801.7, 5142976, 5540976 (xmin, xmax, ymin, ymax) ## crs : +proj=utm +zone=55 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 ## names : tas_features.1, tas_features.2, tas_features.3, tas_features.4, tas_features.5, tas_features.6, tas_features.7, tas_features.8, tas_features.9, tas_features.10, tas_features.11, tas_features.12, tas_features.13, tas_features.14, tas_features.15, ... ## min values : 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ... ## max values : 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ... # plot map of the first four vegetation classes plot(tas_features[[1:4]], main = paste(&quot;Feature&quot;, 1:4)) The planning units in this example are a spatial polygon layer—not a raster—and so there can be considerable flexibility in the shape of the planning units. That said, there is a trade-off with the efficiency of data pre-processing in vector-based planning unit data compared to raster-based planning unit data. Vector-based planning unit data generally require more time to complete pre-processing computations (e.g. overlaying the planning unit data with the feature data, or generating boundary data). As a consequence, we generally recommend using raster-based planning unit data where possible to reduce processing time—but note that this is not possible when not all planning units are equal-sized squares. Another strategy is to complete the pre-processing in other software environments (e.g. ArcGIS) and use the pre-processed data directly with the prioritizr package. 5.2 Marxan problem formulation Here, we will provide an example of using the marxan_problem function to build and solve a typical Marxan conservation planning problem. Then we will show how this same problem can be built and solved using the fully customizable problem function as a comparison. The dataset used in this example follows many of the conventions used by the Marxan decision support tool. As a consequence, it is not too difficult to format the data for use with the marxan_problem function. The marxan_problem function is essentially a wrapper to the problem function. This means that when we solve problems created using the marxan_problem function, we will solve them using exact algorithms and not the simulated annealing algorithm used by Marxan. All problem objects formulated with marxan_problem use the minimum set objective. Targets can be either relative or absolute, and planning units can be specified for masking in or out using the locked_in and locked_out arguments. To favor clumped solutions, use the penalty argument to impose a penalty on solutions with high boundary lengths (equivalent to the Boundary Length Modifier (BLM) used in Marxan), and the edge_factor argument to scale the penalty for edges that do not have neighboring planning units, such as the coastline. For simplicity we set all of the targets at the same level, 17 %, to reflect the Aichi biodiversity target to “safeguard” at least 17% of terrestrial ecosystems by 2020. For example, to prioritize planning units in Tasmania that meet the 17 % representation target at the least cost. First, we will convert the vector-based planning unit data and raster-based feature data into the tabular formats required by the marxan_problem function. These formats are very similar to the formats used by Marxan. # create table with planning unit data pu_data &lt;- tas_pu@data # print first six rows head(pu_data) ## id cost status locked_in locked_out ## 0 1 60.24638 0 FALSE FALSE ## 1 2 19.86301 0 FALSE FALSE ## 2 3 59.68051 0 FALSE FALSE ## 3 4 32.41614 0 FALSE FALSE ## 4 5 26.17706 0 FALSE FALSE ## 5 6 51.26218 0 FALSE FALSE # create table with the feature identifiers, names, and targets spec_data &lt;- data.frame(id = seq_len(nlayers(tas_features)), name = paste0(&quot;veg&quot;, seq_len(nlayers(tas_features))), prop = 0.17) # print first six rows head(spec_data) ## id name prop ## 1 1 veg1 0.17 ## 2 2 veg2 0.17 ## 3 3 veg3 0.17 ## 4 4 veg4 0.17 ## 5 5 veg5 0.17 ## 6 6 veg6 0.17 # create table with the planning unit vs. feature data puvspr_data &lt;- rij_matrix(tas_pu, tas_features) puvspr_data &lt;- as(puvspr_data, &quot;dgTMatrix&quot;) puvspr_data &lt;- data.frame(pu = puvspr_data@j + 1, species = puvspr_data@i + 1, amount = puvspr_data@x) # print first six rows head(puvspr_data) ## pu species amount ## 1 3 54 1.000000e+00 ## 2 3 59 1.165971e+01 ## 3 5 30 1.000000e+00 ## 4 6 27 1.000000e+00 ## 5 6 35 1.000000e+00 ## 6 6 59 3.635182e-05 # create table with the boundary data bound_data &lt;- boundary_matrix(tas_pu) bound_data &lt;- as(bound_data, &quot;dgTMatrix&quot;) bound_data &lt;- data.frame(id1 = bound_data@i + 1, id2 = bound_data@j + 1, boundary = bound_data@x) # print first six rows head(bound_data) ## id1 id2 boundary ## 1 1 1 6314.6621 ## 2 3 1 3922.9264 ## 3 6 1 150.3778 ## 4 2 2 23958.6982 ## 5 4 2 3233.3056 ## 6 7 2 4639.9220 Now that we have converted the data to tabular format, we can use the marxan_problem function to create a conservation planning problem. # create problem p1 &lt;- marxan_problem(pu_data, spec_data, puvspr_data, bound_data, blm = 0.0005) # print problem print(p1) ## Conservation Problem ## planning units: data.frame (1130 units) ## cost: min: 0.19249, max: 61.92727 ## features: veg1, veg2, veg3, ... (62 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.17, max: 0.17)] ## decisions: default ## constraints: &lt;Locked in planning units [257 locked units]&gt; ## penalties: &lt;Boundary penalties [edge factor (min: 1, max: 1), penalty (5e-04), zones]&gt; ## portfolio: default ## solver: default Next, we can solve the problem (see ?solve for more information). The prioritizr R package supports three different exact algorithm software packages: gurobi, Rsymphony, and lpsymphony. There are costs and benefits associated with each of these different solvers, but each software should return similar results. Note that you will need at least one of these package installed on your system to solve problems. We recommend using the gurobi solver if possible, and have used this solver when building this tutorial. After solving the problem, we will calculate some statistics to describe the solution. Note that the planning unit selections are stored in the “solution_1” column of the solution object. # solve problem s1 &lt;- solve(p1) ## Gurobi Optimizer version 9.1.1 build v9.1.1rc0 (mac64) ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ## Optimize a model with 6358 rows, 4278 columns and 14496 nonzeros ## Model fingerprint: 0xa2fb0a5e ## Variable types: 0 continuous, 4278 integer (4278 binary) ## Coefficient statistics: ## Matrix range [2e-06, 4e+01] ## Objective range [5e-02, 2e+02] ## Bounds range [1e+00, 1e+00] ## RHS range [1e-01, 1e+02] ## Found heuristic solution: objective 30263.129158 ## Found heuristic solution: objective 12512.071934 ## Presolve removed 1793 rows and 1168 columns ## Presolve time: 0.03s ## Presolved: 4565 rows, 3110 columns, 10169 nonzeros ## Found heuristic solution: objective 11803.383927 ## Variable types: 0 continuous, 3110 integer (3110 binary) ## Presolved: 4565 rows, 3110 columns, 10169 nonzeros ## ## ## Root relaxation: objective 1.076817e+04, 808 iterations, 0.04 seconds ## ## Nodes | Current Node | Objective Bounds | Work ## Expl Unexpl | Obj Depth IntInf | Incumbent BestBd Gap | It/Node Time ## ## 0 0 10768.1736 0 137 11803.3839 10768.1736 8.77% - 0s ## ## Explored 0 nodes (808 simplex iterations) in 0.10 seconds ## Thread count was 1 (of 8 available processors) ## ## Solution count 3: 11803.4 12512.1 30263.1 ## ## Optimal solution found (tolerance 1.00e-01) ## Best objective 1.180338392702e+04, best bound 1.076817364956e+04, gap 8.7705% # print first six rows of solution object head(s1) ## id cost status locked_in locked_out solution_1 ## 0 1 60.24638 0 FALSE FALSE 0 ## 1 2 19.86301 0 FALSE FALSE 0 ## 2 3 59.68051 0 FALSE FALSE 0 ## 3 4 32.41614 0 FALSE FALSE 0 ## 4 5 26.17706 0 FALSE FALSE 0 ## 5 6 51.26218 0 FALSE FALSE 0 # count number of planning units in solution sum(s1$solution_1) ## [1] 326 # proportion of planning units in solution mean(s1$solution_1) ## [1] 0.2884956 # calculate feature representation r1 &lt;- eval_feature_representation_summary(p1, s1[, &quot;solution_1&quot;, drop = FALSE]) print(r1) ## # A tibble: 62 x 5 ## summary feature total_amount absolute_held relative_held ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 overall veg1 33.9 5.97 0.176 ## 2 overall veg2 170. 40.7 0.239 ## 3 overall veg3 24.0 6.00 0.250 ## 4 overall veg4 32.8 10.4 0.317 ## 5 overall veg5 24.8 4.51 0.182 ## 6 overall veg6 22.0 4.00 0.182 ## 7 overall veg7 16.4 3.06 0.187 ## 8 overall veg8 43.0 9.12 0.212 ## 9 overall veg9 388. 95.3 0.245 ## 10 overall veg10 14.5 5.91 0.407 ## # … with 52 more rows # visualize the solution by converting the solution to a spatial object s1 &lt;- SpatialPolygonsDataFrame(as(tas_pu, &quot;SpatialPolygons&quot;), data = s1) s1$solution_1 &lt;- factor(s1$solution_1) plot(st_as_sf(s1[, &quot;solution_1&quot;]), pal = c(&quot;grey90&quot;, &quot;darkgreen&quot;), main = &quot;marxan_problem solution&quot;) 5.3 General problem formulation Now we will formulate the exact same problem using the problem function and the spatially referenced data. We recommend using this approach instead of the marxan_problem because it is more verbose and you can specify exactly how the conservation planning problem should be formulated. # build problem p2 &lt;- problem(tas_pu, tas_features, cost_column = &quot;cost&quot;) %&gt;% add_min_set_objective() %&gt;% add_relative_targets(0.17) %&gt;% add_locked_in_constraints(&quot;locked_in&quot;) %&gt;% add_binary_decisions() %&gt;% add_boundary_penalties(penalty = 0.0005, edge_factor = 1) # print the problem print(p2) ## Conservation Problem ## planning units: SpatialPolygonsDataFrame (1130 units) ## cost: min: 0.19249, max: 61.92727 ## features: tas_features.1, tas_features.2, tas_features.3, ... (62 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.17, max: 0.17)] ## decisions: Binary decision ## constraints: &lt;Locked in planning units [257 locked units]&gt; ## penalties: &lt;Boundary penalties [edge factor (min: 1, max: 1), penalty (5e-04), zones]&gt; ## portfolio: default ## solver: default # solve problem s2 &lt;- solve(p2) ## Gurobi Optimizer version 9.1.1 build v9.1.1rc0 (mac64) ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ## Optimize a model with 6358 rows, 4278 columns and 14496 nonzeros ## Model fingerprint: 0xa2fb0a5e ## Variable types: 0 continuous, 4278 integer (4278 binary) ## Coefficient statistics: ## Matrix range [2e-06, 4e+01] ## Objective range [5e-02, 2e+02] ## Bounds range [1e+00, 1e+00] ## RHS range [1e-01, 1e+02] ## Found heuristic solution: objective 30263.129158 ## Found heuristic solution: objective 12512.071934 ## Presolve removed 1793 rows and 1168 columns ## Presolve time: 0.03s ## Presolved: 4565 rows, 3110 columns, 10169 nonzeros ## Found heuristic solution: objective 11803.383927 ## Variable types: 0 continuous, 3110 integer (3110 binary) ## Presolved: 4565 rows, 3110 columns, 10169 nonzeros ## ## ## Root relaxation: objective 1.076817e+04, 808 iterations, 0.04 seconds ## ## Nodes | Current Node | Objective Bounds | Work ## Expl Unexpl | Obj Depth IntInf | Incumbent BestBd Gap | It/Node Time ## ## 0 0 10768.1736 0 137 11803.3839 10768.1736 8.77% - 0s ## ## Explored 0 nodes (808 simplex iterations) in 0.09 seconds ## Thread count was 1 (of 8 available processors) ## ## Solution count 3: 11803.4 12512.1 30263.1 ## ## Optimal solution found (tolerance 1.00e-01) ## Best objective 1.180338392702e+04, best bound 1.076817364956e+04, gap 8.7705% # calculate feature representation r2 &lt;- eval_feature_representation_summary(p2, s2[, &quot;solution_1&quot;]) print(r2) ## # A tibble: 62 x 5 ## summary feature total_amount absolute_held relative_held ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 overall tas_features.1 33.9 5.97 0.176 ## 2 overall tas_features.2 170. 40.7 0.239 ## 3 overall tas_features.3 24.0 6.00 0.250 ## 4 overall tas_features.4 32.8 10.4 0.317 ## 5 overall tas_features.5 24.8 4.51 0.182 ## 6 overall tas_features.6 22.0 4.00 0.182 ## 7 overall tas_features.7 16.4 3.06 0.187 ## 8 overall tas_features.8 43.0 9.12 0.212 ## 9 overall tas_features.9 388. 95.3 0.245 ## 10 overall tas_features.10 14.5 5.91 0.407 ## # … with 52 more rows # visualize solution s2$solution_1 &lt;- factor(s2$solution_1) plot(st_as_sf(s2[, &quot;solution_1&quot;]), pal = c(&quot;grey90&quot;, &quot;darkgreen&quot;), main = &quot;problem solution&quot;) 5.4 Selection frequencies Similar to the Marxan decision support tool, we can generate a portfolio of solutions and compute the planning unit selection frequencies to understand their relative importance. This can be useful when trying to understand which planning units in the solution are the most irreplaceable. To do this, we will create a portfolio containing 1000 solutions within 20% of optimality, and calculate the number of times that each planning unit was selected. Note that this requires the Gurobi software to be installed. # create new problem with a portfolio added to it p3 &lt;- p2 %&gt;% add_gap_portfolio(number_solutions = 1000, pool_gap = 0.2) # print problem print(p3) ## Conservation Problem ## planning units: SpatialPolygonsDataFrame (1130 units) ## cost: min: 0.19249, max: 61.92727 ## features: tas_features.1, tas_features.2, tas_features.3, ... (62 features) ## objective: Minimum set objective ## targets: Relative targets [targets (min: 0.17, max: 0.17)] ## decisions: Binary decision ## constraints: &lt;Locked in planning units [257 locked units]&gt; ## penalties: &lt;Boundary penalties [edge factor (min: 1, max: 1), penalty (5e-04), zones]&gt; ## portfolio: Gap portfolio [number_solutions (1000), pool_gap (0.2)] ## solver: default # generate solutions s3 &lt;- solve(p3) # find column numbers with the solutions solution_columns &lt;- which(grepl(&quot;solution&quot;, names(s3))) # calculate selection frequencies s3$selection_frequencies &lt;- rowSums(as.matrix(s3@data[, solution_columns])) # plot first four solutions in the portfolio s3$solution_1 &lt;- factor(s3$solution_1) s3$solution_2 &lt;- factor(s3$solution_2) s3$solution_3 &lt;- factor(s3$solution_3) s3$solution_4 &lt;- factor(s3$solution_4) plot(st_as_sf(s3[, c(&quot;solution_1&quot;, &quot;solution_2&quot;, &quot;solution_3&quot;, &quot;solution_4&quot;)]), pal = c(&quot;grey90&quot;, &quot;darkgreen&quot;)) # plot histogram of selection frequencies hist(s3$selection_frequencies, main = &quot;Selection frequencies&quot;, xlab = &quot;Number of times units were selected&quot;) # plot spatial distribution of the selection frequencies plot(st_as_sf(s3[, &quot;selection_frequencies&quot;]), main = &quot;Selection frequencies&quot;) "],["references-1.html", "References", " References Achterberg, T. &amp; Wunderling, R. (2013). Mixed Integer Programming: Analyzing 12 Years of Progress. Facets of combinatorial optimization: Festschrift for martin grötschel (eds M. Jünger &amp; G. Reinelt), pp. 449–481. Springer, Berlin, Heidelberg. Ball, I.R., Possingham, H. &amp; Watts, M.E. (2009). Marxan and relatives: Software for spatial conservation prioritisation. Spatial Conservation Prioritisation: Quantitative Methods &amp; Computational Tools (eds A. Moilanen, K.A. Wilson &amp; H. Possingham), pp. 185–189. Oxford University Press, Oxford, UK. Beyer, H.L., Dujardin, Y., Watts, M.E. &amp; Possingham, H.P. (2016). Solving conservation planning problems with integer linear programming. Ecological Modelling, 328, 14–22. Billionnet, A. (2013). Mathematical optimization ideas for biodiversity conservation. European Journal of Operational Research, 231, 514–534. Butchart, S.H., Clarke, M., Smith, R.J., Sykes, R.E., Scharlemann, J.P., Harfoot, M., Buchanan, G.M., Angulo, A., Balmford, A., Bertzky, B. &amp; others. (2015). Shortfalls and solutions for meeting national and global conservation area targets. Conservation Letters, 8, 329–337. Cabeza, M. &amp; Moilanen, A. (2001). Design of reserve networks and the persistence of biodiversity. Trends in Ecology &amp; Evolution, 16, 242–248. Cabeza, M. &amp; Moilanen, A. (2006). Replacement cost: A practical measure of site value for cost-effective reserve planning. Biological Conservation, 132, 336–342. Church, R.L., Stoms, D.M. &amp; Davis, F.W. (1996). Reserve selection as a maximal covering location problem. Biological conservation, 76, 105–112. Faith, D.P. (1992). Conservation evaluation and phylogenetic diversity. Biological Conservation, 61, 1–10. Ferrier, S., Pressey, R.L. &amp; Barrett, T.W. (2000). A new predictor of the irreplaceability of areas for achieving a conservation goal, its application to real-world planning, and a research agenda for further refinement. Biological Conservation, 93, 303–325. Fuller, R.A., McDonald-Madden, E., Wilson, K.A., Carwardine, J., Grantham, H.S., Watson, J.E., Klein, C.J., Green, D.C. &amp; Possingham, H.P. (2010). Replacing underperforming protected areas achieves better conservation outcomes. Nature, 466, 365. Kirkpatrick, J.B. (1983). An iterative method for establishing priorities for the selection of nature reserves: An example from Tasmania. Biological Conservation, 25, 127–134. Kirkpatrick, S., Gelatt, C.D. &amp; Vecchi, M.P. (1983). Optimization by simulated annealing. Science, 220, 671–680. Klein, C., Carwardine, J., Wilson, K., Watts, M. &amp; Possingham, H. (2007). Spatial Prioritization Approaches for the Conservation of Biodiversity in Australia: Considering Conservation Costs, Ecological &amp; Evolutionary Processes, and Large-Intact Areas. Report to the Department of Environment; Water Resources. Klein, C., Wilson, K., Watts, M., Stein, J., Berry, S., Carwardine, J., Smith, M.S., Mackey, B. &amp; Possingham, H. (2009). Incorporating ecological and evolutionary processes into continental-scale conservation planning. Ecological Applications, 19, 206–217. Margules, C.R. &amp; Pressey, R.L. (2000). Systematic conservation planning. Nature, 405, 243–253. Moilanen, A. (2007). Landscape Zonation, benefit functions and target-based planning: Unifying reserve selection strategies. Biological Conservation, 134, 571–579. Nicholls, A.O. &amp; Margules, C.R. (1993). An upgraded reserve selection algorithm. Biological Conservation, 64, 165–169. Pressey, R.L., Possingham, H.P. &amp; Margules, C.R. (1996). Optimality in reserve selection algorithms: When does it matter and how much? Biological Conservation, 76, 259–267. Rodrigues, A.S., Akcakaya, H.R., Andelman, S.J., Bakarr, M.I., Boitani, L., Brooks, T.M., Chanson, J.S., Fishpool, L.D., Da Fonseca, G.A., Gaston, K.J. &amp; others. (2004). Global gap analysis: Priority regions for expanding the global protected-area network. BioScience, 54, 1092–1100. Rodrigues, A.S. &amp; Gaston, K.J. (2002). Maximising phylogenetic diversity in the selection of networks of conservation areas. Biological Conservation, 105, 103–111. Rodrigues, A.S., Orestes Cerdeira, J. &amp; Gaston, K.J. (2000). Flexibility, efficiency, and accountability: Adapting reserve selection algorithms to more complex conservation problems. Ecography, 23, 565–574. Rosauer, D., Laffan, S.W., Crisp, M.D., Donnellan, S.C. &amp; Cook, L.G. (2009). Phylogenetic endemism: A new approach for identifying geographical concentrations of evolutionary history. Molecular Ecology, 18, 4061–4072. Stigner, M.G., Beyer, H.L., Klein, C.J. &amp; Fuller, R.A. (2016). Reconciling recreational use and conservation values in a coastal protected area. Journal of Applied Ecology, 53, 1206–1214. Watts, M.E., Ball, I.R., Stewart, R.S., Klein, C.J., Wilson, K., Steinback, C., Lourival, R., Kircher, L. &amp; Possingham, H.P. (2009). Marxan with Zones: Software for optimal conservation based land- and sea-use zoning. Environmental Modelling &amp; Software, 24, 1513–1521. Williams, P., Gibbons, D., Margules, C., Rebelo, A., Humphries, C. &amp; Pressey, R. (1996). A comparison of richness hotspots, rarity hotspots, and complementary areas for conserving diversity of British birds. Conservation Biology, 10, 155–174. "]]
